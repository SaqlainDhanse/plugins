/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <screenfade_util>
#include <cstrike>
#include <cs_player_models_api>
#include <hamsandwich>
#include <fakemeta>
#include <engine>
#include <fun>
#include <nvault>
#include <newmenus>
#include <messages>
#include <string>
#include <round_terminator>
#include <sqlx>

//LAST EDIT 29TH MAY 2019 : DusT
#define is_user_registered(%1) is_user_connected(%1)
//native is_user_registered(id)

#define PLUGIN "Jailbreak_Main"
#define VERSION "1.0"
#define AUTHOR "Saqlain aka DusT"
#define ADMIN_SUPER (1<<21)
#define MAX_NAME_LENGTH 32

#define TAG "^1[ ^3Jailbreak ^1]"
#define TASK_HUDMESSAGE 90000
#define TASK_BEACON 80000
#define TASK_DAY_LENGTH 70000
#define TASK_VOTEDAY_TIMER 60000
#define TASK_LR_TIMER 324320400

#define JB_MENU_ITEM_DONT_SHOW 1
#define JB_MENU_ITEM_UNAVAILABLE 2
#define JB_SHOP_ITEM_IGNORE_COST 3

#define JB_LR_OTHER_MENU 1

#define JB_BLOCK_JOIN_GUARDS 2
#define JB_BLOCK_JOIN_PRISONERS 1
#define JB_BLOCK_JOIN_BOTH 3

#define MAX_WEAPONS 5
#define MAX_VOTEDAYS 5

#define OFFSET_TEAM	114
#define fm_get_user_team(%1)	(clamp(get_pdata_int(%1,OFFSET_TEAM),TEAM_ANY,TEAM_SPECTATOR))
#define fm_set_user_team(%1,%2)	set_pdata_int(%1,OFFSET_TEAM,%2)

/*
new const CASH_DB_HOST[] = "188.165.251.11";
new const CASH_DB_USER[] = "hlds_source";
new const CASH_DB_PASS[] = "";
new const CASH_DB_NAME[] = "hlds_source";
new const CASH_DB_TABLE[] = "jb_cash";
*/
new const iWeapons_bpammo[] = { 1, 52, 1, 90, 1, 32, 1, 100, 90, 1, 120, 100, 100, 90, 90, 90, 100, 120,
			30, 120, 200, 32, 90, 120, 90, 1, 35, 90, 90, 1, 100 }

new const gclasses_defmodels[][] = {
	"gign",
	"gsg9",
	"spetsnaz",
	"urban"
}

new const pclasses_defmodels[][] = {
	"leet",
	"terror",
	"guerilla",
	"arctic"
}

new const default_vknife_model[] = "models/v_knife.mdl"
new const default_pknife_model[] = "models/p_knife.mdl"

new const jb_cvar_cfg_file[] = "jailbreak.cfg";
new const jb_shop_ini_file[] = "jailbreak_shop.ini";
new const jb_classes_ini_file[] = "jailbreak_classes.ini";
new const jailbreak_ini_file[] = "jailbreak.ini";

enum (+=1)
{
	DAY_SAT = 0,
	DAY_SUN,
	DAY_MON,
	DAY_TUE,
	DAY_WED,
	DAY_THU,
	DAY_FRI,
	
	MAX_DAYS
}

new const sDays[MAX_DAYS][] = {
	"Saturday",
	"Sunday",
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday"
}

new iToday
new g_fw_return
new fw_jbmm_item_selected, fw_lr_item_selected, fw_lr_duel_started, fw_shop_item_select_pre, fw_shop_item_select_post,
 fw_shop_item_bought, fw_day_postselected, fw_day_preselected, fw_day_ended, fw_round_start, fw_round_end, fw_day_start,
  fw_lr_duel_ended, fw_jbmm_itemadded, fw_pretouch_wpnbox, fw_class_creation, fwd_teamhandling;
new Game_HudSyncObj, StatusValue_HudSyncObj;
new Array:g_lr_itemname, Array:g_lr_itemaccess
new Array:g_shop_items_name, Array:g_shop_items_info, Array:g_shop_items_cost, Array:g_shop_items_access, Array:g_shop_items_team, Array:g_shop_items_bitsumdays;
new Array:g_jbmm_itemname, Array:g_jbmm_itemaccess, Array:g_jbmm_itemteam;
new Array:g_days_itemname, Array:g_days_itemaccess, Array:g_days_itemlength, Array:g_days_dayendtype;
new Array:g_classes_array;
new g_jbmm_items, g_lr_items, g_shop_items, g_days_items, g_logmessages_hooks, Array:g_array_logmessages;

//configs variable
new CONFIGS_DIR[64];

// nvaults
new /*g_nvault_cash,*/ g_nvault_cells_button;
//new Handle:CashDbTuple = Empty_Handle;

new user_cash[33]
new g_iLRPrisoner, g_iLRGuard;

#define set_flag(%1,%2)		(%1 |= (1 << (%2 & 31)))
#define remove_flag(%1,%2)		(%1 &= ~(1 << (%2 & 31)))
#define check_flag(%1,%2)		(%1 & (1 << (%2 & 31)))

new g_user_wpns_blocked[33] // Bitsum

new g_votedays_voted   // Bitsum
new g_votedays_vote[MAX_VOTEDAYS]
new g_votedays_chosen[MAX_VOTEDAYS]
new g_votedays_timer
new Float:g_day_length
new g_has_avotedaymenu   // Bitsum

new IsUserAlive;
new g_cells_button = -1;
new g_lr_inprogress = -1;
new g_day_inprogress = -1;

// Maxplayers
new g_iMaxplayers;

// Message's ID
new g_msgStatusIcon, g_msgTeamInfo, g_msgSayText, g_msgMoney, g_msgSendAudio, g_msgTextMsg, fwMessage_sendaudio, fwMessage_textmsg;

// MODE
new MODE[64];

enum _:TEAM_MAX(+=1)
{
	TEAM_ANY = 0,
	TEAM_PRISONERS,
	TEAM_GUARDS,
	TEAM_SPECTATOR
}

enum (+=1)
{
	FLAG_ALL = -1,
	FLAG_ALIVE_ONLY,
	FLAG_DEAD_ONLY
}

#define WEAPON_LINUXDIFF	4
#define PLAYER_LINUXDIFF	5

// OFFSETS
const m_iPlayerTeam = 114
const m_iWeaponOwner = 41

new BEACON_SOUND[64] = "buttons/blip1.wav";

new blue_duelSpr, red_duelSpr, beaconSpr;

new g_iClass[33][TEAM_MAX]
new g_iNextClass[33]

new g_iClasses;

new const SZTEAMS[][] = {
	"ANY",
	"PRISONER",
	"GUARD",
	"SPECTATOR"
}

// knife sounds
new const knife_sounds[][] = {
	"_deploy1.wav",
	"_hit1.wav",
	"_hit2.wav",
	"_hit3.wav",
	"_hit4.wav",
	"_hitwall1.wav",
	"_slash1.wav",
	"_slash2.wav",
	"_stab.wav"
}

enum _:Day_EndType (+=1)
{
	DAY_ONE_SURVIVOR = 0,
	DAY_GUARDS_VS_PRISONERS,
	DAY_TIMER
}

enum _:LOGS_MESSAGES_DATA (+=1)
{
	LOGMESSAGE_FUNC_ID = 0,
	LOGMESSAGE_FUNC_PLUGIN_ID,
	LOGMESSAGE_MESSAGE[196]
}

public plugin_end()
{
	ArrayDestroy(g_classes_array)
	
	ArrayDestroy(g_jbmm_itemname)
	ArrayDestroy(g_jbmm_itemaccess)
	ArrayDestroy(g_jbmm_itemteam)
	
	// Last request - arrays
	ArrayDestroy(g_lr_itemname)
	ArrayDestroy(g_lr_itemaccess)
	
	// Shop menu - arrays
	ArrayDestroy(g_shop_items_name)
	ArrayDestroy(g_shop_items_info)
	ArrayDestroy(g_shop_items_cost)
	ArrayDestroy(g_shop_items_access)
	ArrayDestroy(g_shop_items_team)
	ArrayDestroy(g_shop_items_bitsumdays)
	
	// Days menu - arrays
	ArrayDestroy(g_days_itemname)
	ArrayDestroy(g_days_itemaccess)
	ArrayDestroy(g_days_itemlength)
	ArrayDestroy(g_days_dayendtype)
	
	// close the nvaults..
	//nvault_close(g_nvault_cash)
	//SQL_FreeHandle(CashDbTuple);
	nvault_close(g_nvault_cells_button)
	
	// function array
	ArrayDestroy(g_array_logmessages)
}

enum _:CLASSES_KEYS (+=1)
{
	KEY_CLASS_TEAM = 0,
	KEY_CLASS_NAME,
	KEY_CLASS_MODEL,
	KEY_CLASS_PRIMARY_WEAPON,
	KEY_CLASS_SECONDARY_WEAPON,
	KEY_CLASS_V_KNIFE,
	KEY_CLASS_P_KNIFE,
	KEY_CLASS_KNIFE_SOUNDS,
	KEY_CLASS_FLAGS
}

new const szClasses_keys[][] = {
	"TEAM",
	"NAME",
	"MODEL",
	"PRIMARY_WEAPON",
	"SECONDARY_WEAPON",
	"V_KNIFE",
	"P_KNIFE",
	"KNIFE_SOUNDS",
	"FLAGS"
}

enum _:CLASSES_DATA (+=1)
{
	CLASS_TEAM[10] = 0,
	CLASS_NAME[32],
	CLASS_MODEL[32],
	CLASS_PRIMWEAPONS[64],
	CLASS_SECWEAPONS[64],
	CLASS_V_KNIFE_MDL[64],
	CLASS_P_KNIFE_MDL[64],
	CLASS_KNIFE_SOUNDS[64],
	CLASS_FLAGS
}

new const sClasses[][CLASSES_DATA] = {
	{ "GUARD", "Hunter", "spetsnaz", "p90,mp5navy,ump45,tmp,mac10", "elite,usp,glock18", "", "", "", ADMIN_ALL },

	{ "GUARD", "Assault", "gign", "m4a1,ak47,famas,galil", "deagle,usp,glock18", "", "", "", ADMIN_ALL },
	
	{ "GUARD", "Heavy-Gunner", "gsg9", "m249", "deagle,usp,glock18", "", "", "", ADMIN_ALL },
	
	{ "GUARD", "Sniper", "sas", "awp,scout", "deagle,usp,glock18", "", "", "", ADMIN_ALL },
	
	{ "GUARD", "Shot-Gunner", "urban", "m3,xm1014", "deagle,usp,glock18", "", "", "", ADMIN_ALL },
	
	{ "GUARD", "VIP", "vip", "m4a1,ak47,awp,p90,mp5navy,m3,xm1014", "deagle,usp,glock18", "", "", "", ADMIN_RESERVATION },
	
	{ "PRISONER", "L33t", "leet", "", "", "", "", "", ADMIN_ALL },
	
	{ "PRISONER", "Terror", "terror", "", "", "", "", "", ADMIN_ALL },
	
	{ "PRISONER", "Guerilla", "guerilla", "", "", "", "", "", ADMIN_ALL },
	
	{ "PRISONER", "Arctic", "arctic", "", "", "", "", "",  ADMIN_ALL }
}


load_jailbreak_classes_file()
{
	new xArray[CLASSES_DATA], fp, sFile[64];
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_classes_ini_file);
	
	// Execute class creation fw...
	ExecuteForward(fw_class_creation, g_fw_return);
	
	if(!file_exists(sFile))
	{
		write_file(sFile, "; Classes Configuration")
		
		for(new i, szFlags[24]; i < sizeof sClasses; i++)
		{
			copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sClasses[i][CLASS_NAME]);
			copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), sClasses[i][CLASS_TEAM]);
			copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), sClasses[i][CLASS_MODEL]);
			copy(xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]), sClasses[i][CLASS_PRIMWEAPONS]);
			copy(xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]), sClasses[i][CLASS_SECWEAPONS]);
			xArray[CLASS_FLAGS] = sClasses[i][CLASS_FLAGS];
			
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MODEL], xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]))
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_PRIMARY_WEAPON], xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]))
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_SECONDARY_WEAPON], xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]))
			get_flags(xArray[CLASS_FLAGS], szFlags, charsmax(szFlags))
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_FLAGS], szFlags, charsmax(szFlags))
			get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_TEAM], xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]))
		}
	}
	
	fp = fopen(sFile, "at+");
	
	if(!fp)
	{
		set_fail_state("Error opening the file!")
		return 0;
	}
	
	new sBuffer[256], szKey[48], registered,
		count, j, i, maxloop, xArray2[CLASSES_DATA],
			sizeofkeys = sizeof szClasses_keys, szFile[64];
	
	while(!feof(fp))
	{
		fgets(fp, sBuffer, charsmax(sBuffer));
		trim(sBuffer);
		
		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;
		
		if(sBuffer[0] == '[')
		{
			if((0 <= count < sizeofkeys) && g_iClasses > 0)
			{
				for(j = 0; j < sizeofkeys; j++)
				{
					if(!(registered & (1<<j)))
					{
						registered |= (1<<j);
						count++;
						
						switch( j )
						{
							case KEY_CLASS_TEAM: copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), "SPECTATORS")
							case KEY_CLASS_NAME: copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), "ENTER_CLASS_NAME");
							case KEY_CLASS_MODEL: copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), "NONE");
							case KEY_CLASS_V_KNIFE: copy(xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]), default_vknife_model);
							case KEY_CLASS_P_KNIFE: copy(xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]), default_pknife_model);
							case KEY_CLASS_PRIMARY_WEAPON: xArray[CLASS_PRIMWEAPONS][0] = 0;
							case KEY_CLASS_SECONDARY_WEAPON: xArray[CLASS_SECWEAPONS][0] = 0;
							case KEY_CLASS_KNIFE_SOUNDS: xArray[CLASS_KNIFE_SOUNDS][0] = 0;
							case KEY_CLASS_FLAGS: xArray[CLASS_FLAGS] = 0;
						}
					}
				}
				
				ArraySetArray(g_classes_array, (g_iClasses-1), xArray);
			}
			
			count = 0;
			registered = (1<<KEY_CLASS_NAME);
			copyc(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sBuffer[1], ']');
			
			for(i = 0, maxloop = ArraySize(g_classes_array); i < maxloop; i++)
			{
				ArrayGetArray(g_classes_array, i, xArray2);
				if(equal(xArray[CLASS_NAME], xArray2[CLASS_NAME]))
				{
					count = sizeofkeys;
					i = maxloop;
				}
			}
			
			if(count == sizeofkeys)
			{
				continue;
			}
			
			ArrayPushArray(g_classes_array, xArray)
			
			g_iClasses++;
			continue;
		}
		
		if(count >= sizeofkeys || !g_iClasses) continue;
		
		strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=');
		trim(szKey);
		trim(sBuffer);
		remove_quotes(szKey);
		remove_quotes(sBuffer);
		
		for(j = 0; j < sizeofkeys; j++)
		{
			if(equali(szClasses_keys[j], szKey) && !(registered & (1<<j)))
			{
				registered |= (1<<j);
				count++;
				
				ArrayGetArray(g_classes_array, (g_iClasses-1), xArray)
				
				switch( j )
				{
					case KEY_CLASS_FLAGS: xArray[CLASS_FLAGS] = read_flags(sBuffer);
					case KEY_CLASS_NAME: copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), sBuffer);
					case KEY_CLASS_MODEL:
					{
						copy(xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]), sBuffer);
						formatex(szFile, charsmax(szFile), "models/player/%s/%s.mdl", sBuffer, sBuffer);
						precache_model(szFile);
						formatex(szFile, charsmax(szFile), "models/player/%s/%sT.mdl", sBuffer, sBuffer)
						if(file_exists(szFile)) precache_model(szFile);
					}
					case KEY_CLASS_PRIMARY_WEAPON: copy(xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]), sBuffer);
					case KEY_CLASS_SECONDARY_WEAPON: copy(xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]), sBuffer);
					case KEY_CLASS_TEAM: copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), sBuffer);
					case KEY_CLASS_V_KNIFE:
					{
						copy(xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]), sBuffer);
						precache_model(sBuffer);
					}
					case KEY_CLASS_P_KNIFE:
					{
						copy(xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]), sBuffer);
						precache_model(sBuffer);
					}
					case KEY_CLASS_KNIFE_SOUNDS:
					{
						copy(xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]), sBuffer);
						
						for(new i; i < sizeof knife_sounds; i++)
						{
							formatex(szFile, charsmax(szFile), "%s%s", sBuffer, knife_sounds[i]);
							precache_sound(szFile);
						}
					}
				}
				
				ArraySetArray(g_classes_array, (g_iClasses-1), xArray);
				
				j = sizeofkeys;
			}
		}
	}
	fclose(fp);
	
	log_amx("[JAILBREAK] CLASSES HAS BEEN SUCCESSFULLY LOADED !")
	log_amx("[JAILBREAK] FILE DIRECTORY : '%s'", sFile)
	
	return 1;
}

public plugin_precache()
{
	// getting the configs direct folder...
	get_configsdir(CONFIGS_DIR, charsmax(CONFIGS_DIR))
	
	// Forward for class creating !!!
	fw_class_creation = CreateMultiForward("jb_class_creation", ET_IGNORE)
	
	// Classes menu - array
	g_classes_array = ArrayCreate(395, 1);
	
	new BLUE_DUEL_SPRITE[64] = "sprites/duel_blue.spr";
	new RED_DUEL_SPRITE[64] = "sprites/duel_red.spr";
	new BEACON_SPRITE[64] = "sprites/laserbeam.spr";
	
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_GUARD_SPR", BLUE_DUEL_SPRITE, charsmax(BLUE_DUEL_SPRITE))
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_PRISONER_SPR", RED_DUEL_SPRITE, charsmax(RED_DUEL_SPRITE))
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_BEACON_SPR", BEACON_SPRITE, charsmax(BEACON_SPRITE))
	
	blue_duelSpr = precache_model(BLUE_DUEL_SPRITE);
	red_duelSpr = precache_model(RED_DUEL_SPRITE);
	beaconSpr = precache_model(BEACON_SPRITE);
	
	get_file_keyvalue(jailbreak_ini_file, "EFFECTS", "LR_BEACON_SOUND", BEACON_SOUND, charsmax(BEACON_SOUND))
	precache_sound(BEACON_SOUND)
	
	// LOAD CLASSES
	load_jailbreak_classes_file();
	
	// Disallowing buying...
	new info_map_para;
	if(!(info_map_para = find_ent_by_class(-1,"info_map_parameters")))
	{
		info_map_para = create_entity("info_map_parameters");
	}
	
	DispatchKeyValue(info_map_para, "buying", "3");
	DispatchSpawn(info_map_para);
}
/*
public OnRoundEnd( const RoundEndType:type )
{
	new returnNum = PLUGIN_CONTINUE;
	if(g_day_inprogress > -1)
	{
		switch ( ArrayGetCell(g_days_dayendtype, g_day_inprogress) )
		{
			case DAY_ONE_SURVIVOR:
			{
				new players[32], pnum;
				get_players(players, pnum, "ah");
				returnNum = (pnum > 1) ? PLUGIN_HANDLED:PLUGIN_CONTINUE;
				
				if(pnum == 1)
				{
					// block win messages & audio...
					if(!fwMessage_sendaudio) fwMessage_sendaudio = register_message(g_msgSendAudio, "message_sendaudio"); 
					if(!fwMessage_textmsg) fwMessage_textmsg = register_message(g_msgTextMsg, "message_textmsg"); 
					
					new szName[32], player = players[0], sTeam[16], sAuthid[32];
					get_user_name(player, szName, charsmax(szName))
					get_user_authid(player, sAuthid, charsmax(sAuthid))
					get_user_team(player, sTeam, charsmax(sTeam))
					client_print(0, print_center, "%s Win!", szName)
					
					new szDayname[32];
					ArrayGetString(g_days_itemname, g_day_inprogress, szDayname, charsmax(szDayname))
					
					logevent_message("^"<%s><%d><%s><%s>^" has won the ^"%s^" day!",
					szName, get_user_userid(player), sAuthid, sTeam, szDayname)
					return PLUGIN_CONTINUE;
				}
			}
			case DAY_GUARDS_VS_PRISONERS: returnNum = PLUGIN_CONTINUE;
			case DAY_TIMER: returnNum = g_day_length > 0.0 ? PLUGIN_HANDLED:PLUGIN_CONTINUE;
		}
	}
	
	if(returnNum == PLUGIN_CONTINUE)
	{
		switch( type )
		{
			case RoundEndType_TerroristWin:
			{
				// block win messages & audio...
				if(!fwMessage_sendaudio) fwMessage_sendaudio = register_message(g_msgSendAudio, "message_sendaudio"); 
				if(!fwMessage_textmsg) fwMessage_textmsg = register_message(g_msgTextMsg, "message_textmsg"); 
				logevent_message("Prisoners win!");
			}
			case RoundEndType_CTWin:
			{
				// block win messages & audio...
				if(!fwMessage_sendaudio) fwMessage_sendaudio = register_message(g_msgSendAudio, "message_sendaudio"); 
				if(!fwMessage_textmsg) fwMessage_textmsg = register_message(g_msgTextMsg, "message_textmsg"); 
				logevent_message("Guards win!");
			}
		}
	}
	
	return returnNum;
}
*/
public Show_weaponsmenu(id, wpns[], const title[], const handler[])
{
	if(!Check_weapons_available(id, true))
		return;
	
	trim(wpns)
	remove_quotes(wpns)
	
	new sOutput[MAX_WEAPONS][24], sInfo[24];
	str_explode(wpns, ',', sOutput, MAX_WEAPONS, charsmax(sOutput[]))
	
	new iMenu = menu_create(title, handler)
	
	for( new i = 0; i < MAX_WEAPONS; i++)
	{
		strtolower(sOutput[i])
		formatex(sInfo, charsmax(sInfo), "weapon_%s", sOutput[i])
		
		if(!get_weaponid(sInfo))
			continue;
		
		menu_additem(iMenu, sOutput[i], sInfo)
	}
	menu_display(id, iMenu)
}

public primary_wpnshandle(id, menu, item)
{
	if(item == MENU_EXIT || !Check_weapons_available(id, false))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sName[32], sData[24]
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	
	menu_destroy(menu);
	
	new wpnid = get_weaponid(sData)
	
	ham_give_weapon(id, sData)
	cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid])
	
	set_task(0.2, "Show_Secondarywpns", id)
	return PLUGIN_HANDLED;
}

public Show_Secondarywpns(id)
{
	if(!Check_weapons_available(id, true))
		return;
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, g_iClass[id][TEAM_GUARDS], xArray)
	Show_weaponsmenu(id, xArray[CLASS_SECWEAPONS], "\r[ \yJailbreak \r] \wChoose your secondary weapon..", "secondary_wpnshandle")
}

public secondary_wpnshandle(id, menu, item)
{
	if(item == MENU_EXIT || !Check_weapons_available(id,false))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
	new sName[32], sData[24];
	new iAccess, iCallback;
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	
	menu_destroy(menu);
	
	new wpnid = get_weaponid(sData)
	
	ham_give_weapon(id, sData)
	cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid])
	return PLUGIN_HANDLED
}

bool:Check_weapons_available(id, bool:bMsg=false)
{
	if(g_lr_inprogress != -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS")
		return false;
	}
	if(g_day_inprogress != -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "DAY_INPROGRESS")
		return false;
	}
	if(!check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_NOT_ALIVE")
		return false;
	}
	
	return true;
}

public give_weapons(id, wpns[], delimiter)
{
	if(!Check_weapons_available(id, true))
		return;
	
	new sOutput[MAX_WEAPONS][24]
	str_explode(wpns, delimiter, sOutput, MAX_WEAPONS, 23)
	
	new wpnid, sWpnname[24]
	
	for(new i = 0; i < MAX_WEAPONS; i++)
	{
		formatex(sWpnname, charsmax(sWpnname), "weapon_%s", sOutput[i])
		wpnid = get_weaponid(sWpnname)
		
		if(!wpnid) continue;
		
		ham_give_weapon(id, sWpnname)
		cs_set_user_bpammo(id, wpnid, iWeapons_bpammo[wpnid])
	}
}

public pfn_keyvalue(Entity)  
{ 
	new ClassName[ 20 ], Dummy[ 2 ];
	copy_keyvalue( ClassName, charsmax( ClassName ), Dummy, charsmax( Dummy ), Dummy, charsmax( Dummy ) );
	
	if(equal(ClassName, "hostage_entity") ||
		equal(ClassName, "func_hostage_rescue") ||
		equal(ClassName, "func_bomb_target") ||
		equal(ClassName, "func_buyzone") ||
		equal(ClassName, "func_escapezone") ||
		equal(ClassName, "func_vip_safetyzone"))
	{
		remove_entity(Entity);
		return PLUGIN_HANDLED;
	}
	
	return PLUGIN_CONTINUE;
}

public plugin_natives()
{
	// Create a library !!!
	register_library("jailbreak_core")
	
	// JailBreak Main Menu - arrays
	g_jbmm_itemname = ArrayCreate(64, 1);
	g_jbmm_itemaccess = ArrayCreate(1, 1);
	g_jbmm_itemteam = ArrayCreate(1, 1);
	
	// Last request - arrays
	g_lr_itemname = ArrayCreate(64, 1);
	g_lr_itemaccess = ArrayCreate(1, 1);
	
	// Shop menu - arrays
	g_shop_items_name = ArrayCreate(32, 1);
	g_shop_items_info = ArrayCreate(32, 1);
	g_shop_items_cost = ArrayCreate(1, 1);
	g_shop_items_access = ArrayCreate(1, 1);
	g_shop_items_team = ArrayCreate(1, 1);
	g_shop_items_bitsumdays = ArrayCreate(1, 1);
	
	// Days menu - arrays
	g_days_itemname = ArrayCreate(64, 1);
	g_days_itemaccess = ArrayCreate(1, 1);
	g_days_itemlength = ArrayCreate(1, 1);
	g_days_dayendtype = ArrayCreate(1, 1);
	
	// function array
	g_array_logmessages = ArrayCreate(198, 1);
	
	// registeration ...
	register_native("register_jailbreak_mmitem", "_register_jailbreak_mmitem")
	register_native("register_jailbreak_lritem", "_register_jailbreak_lritem")
	register_native("register_jailbreak_shopitem", "_register_jailbreak_shopitem")
	register_native("register_jailbreak_day", "_register_jailbreak_day")
	
	// lr natives
	register_native("jb_lr_show_targetsmenu", "_lr_show_targetsmenu")
	register_native("jb_get_current_duel", "_get_current_duel")
	register_native("jb_end_theduel", "_end_theduel")
	register_native("jb_get_duel_name", "_get_duel_name")
	register_native("jb_get_duels_registered", "_get_duels_registered")
	register_native("jb_get_duelid_byname", "_get_duelid_byname")
	
	// shop natives
	register_native("jb_set_user_cash", "_set_user_cash")
	register_native("jb_get_user_cash", "_get_user_cash")
	register_native("jb_update_shop_item", "_update_shop_item")
	register_native("jb_get_shop_items_registered", "_get_shop_items_registered")
	
	// day natives
	register_native("jb_start_theday", "_start_theday")
	register_native("jb_end_theday", "_end_theday")
	register_native("jb_get_day_length", "_get_day_length")
	register_native("jb_set_day_length", "_set_day_length")
	register_native("jb_get_current_day", "_get_current_day")
	register_native("jb_get_day_name", "_get_day_name")
	register_native("jb_get_days_registered", "_get_days_registered")
	register_native("jb_get_dayid_byname", "_get_dayid_byname")
	
	// classes natives
	register_native("register_jailbreak_class", "_create_class")
	register_native("jb_get_user_classid", "_get_user_classid") // native jb_get_user_classid(id)
	register_native("jb_set_user_class", "_set_user_classid") // native jb_set_user_classid(id, classid)
	register_native("jb_get_classname", "_get_classname") // native jb_get_classname(classid, szReturn[], iLen)
	register_native("jb_set_class_newname", "_set_class_newname") // native jb_set_class_newname(classid, const new_name[])
	register_native("jb_is_user_class_valid", "_is_user_class_valid") // native jb_is_class_valid(iClassid)
	register_native("jb_set_user_class_model", "_set_user_class_model")
	
	// block weapons
	register_native("jb_block_user_weapons", "_block_user_weapons")
	register_native("jb_is_user_weapons_blocked", "_is_user_weapons_blocked")
	
	// cells
	register_native("jb_cells", "_cells")
	
	//jailbreak ini file
	register_native("jb_ini_get_keyvalue", "jb_get_keyvalue")
	
	// logmessages hook/native
	register_native("register_jailbreak_logmessages", "register_logmessages")
	register_native("jb_logmessage", "_logmessage")
}

enum CVARS_DATA_VARS
{
	STR_CVARSNAME[32],
	STR_CVARSVALUE[16]
}

enum _:(+=1)
{
	CVAR_GRATIO = 0,
	CVAR_PRATIO,
	CVAR_ADMIN_JOIN,
	CVAR_DUEL_LOST_CASH,
	CVAR_GGIVE_WPNS,
	CVAR_PGIVE_WPNS,
	CVAR_VDAY_TIMER,
	CVAR_VDAY_TIMER2,
	CVAR_LR_TIMER,
	CVAR_VDAY_ADMIN_EXVOTE,
	CVAR_FUNDAYS,
	CVAR_BUTTON_ACTIVATION,
	CVAR_BLOCK_BUTTONS_ONLR,
	CVAR_BLOCK_BUTTONS_ONFUNDAYS,
	CVAR_BLOCK_HEALING_ONLR,
	CVAR_BLOCK_HEALING_ONFUNDAYS,
	
	CVARS_MAX
}

new const CVARS_DATA[CVARS_MAX][CVARS_DATA_VARS] = {
	{ "jb_guards_ratio", "25" },
	{ "jb_prisoners_ratio", "100" },
	{ "jb_admin_join", "1" },
	{ "jb_duel_loose_cash", "20" },
	{ "jb_give_guard_weapons", "1" },
	{ "jb_give_prisoner_weapons", "2" },
	{ "jb_voteday_timer", "15" },
	{ "jb_voteday_daychosen_delay", "5" },
	{ "jb_lastrequest_chosen_delay", "3" },
	{ "jb_voteday_admin_extravote", "1" },
	{ "jb_fundays", "Friday,Thursday" },
	{ "jb_button_activation", "1" },
	{ "jb_block_buttons_onlr", "0" },
	{ "jb_block_buttons_onfundays", "0" },
	{ "jb_block_healing_onlr", "1" },
	{ "jb_block_healing_onfundays", "1" }
}

new g_iCvar_identity[CVARS_MAX]

public plugin_cfg()
{
	// open a vault
	/*g_nvault_cash = nvault_open("jailbreak_cash")
	if(g_nvault_cash == INVALID_HANDLE)
		set_fail_state("Failed to open jailbreak_cash nvault!");*/
	
	
	/*
	CashDbTuple = SQL_MakeDbTuple(CASH_DB_HOST, CASH_DB_USER, CASH_DB_PASS, CASH_DB_NAME);*/
	
	//new query[256];
	/*
	formatex(query, charsmax(query), "CREATE TABLE IF NOT EXISTS %s(id INT NOT NULL AUTO_INCREMENT, name VARCHAR(31) NOT NULL UNIQUE, money INT NOT NULL, PRIMARY KEY(id));", CASH_DB_TABLE);
	SQL_ThreadQuery(CashDbTuple, "@OnCreateTable", query);
*/

	// open a vault
	g_nvault_cells_button = nvault_open("jailbreak_cells_button")
	if(g_nvault_cells_button == INVALID_HANDLE)	
		set_fail_state("Failed to open jailbreak_cells_button nvault!")
	
	new szMapname[32],szValue[8],timestp; get_mapname(szMapname, charsmax(szMapname))
	if(nvault_lookup(g_nvault_cells_button, szMapname, szValue, charsmax(szValue), timestp))
	{
		g_cells_button = str_to_num(szValue);
	}
	// Load Jailbreak Cfg File
	new sFile[64], sBuffer[96]
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, jb_cvar_cfg_file)
	
	if(!file_exists(sFile))
	{
		write_file(sFile, "; Jailbreak Cvar's^n^n")
		
		for(new i = 0; i < sizeof(CVARS_DATA); i++)
		{
			formatex(sBuffer, charsmax(sBuffer), "^"%s^"   ^"%s^"", CVARS_DATA[i][STR_CVARSNAME], CVARS_DATA[i][STR_CVARSVALUE])
			write_file(sFile, sBuffer)
		}
		
		log_amx("Creating '%s' Jailbreak Cvars File!", sFile)
	}
	
	server_cmd("exec %s", sFile);
	
	// Shop items days configuration....
	for(new i, j, item_name[32], szValue[5], szDayname[32]; i < g_shop_items; i++)
	{
		ArrayGetString(g_shop_items_name, i, item_name, charsmax(item_name))
		for(j = 0; j < g_days_items; j++)
		{
			ArrayGetString(g_days_itemname, j, szDayname, charsmax(szDayname))
			strtoupper(szDayname);
			copy(szValue, charsmax(szValue), "NO");
			get_file_keyvalue(jb_shop_ini_file, item_name, szDayname, szValue, charsmax(szValue))
			
			if(equali(szValue, "YES"))
			{
				ArraySetCell(g_shop_items_bitsumdays, i, ArrayGetCell(g_shop_items_bitsumdays,i)|(1<<j+1));
			}
		}
	}
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_event("HLTV", "round_start", "a", "1=0", "2=0");
	register_event("StatusValue", "fw_statusvalue", "be");
	
	register_logevent("round_end", 2, "0=World triggered", "1=Round_End")
	register_logevent("round_end", 2, "0=World triggered", "1&Restart_Round")
	register_logevent("round_end", 2, "0=World triggered", "1=Game_Commencing")
	
	register_clcmd("jointeam", "clcmd_join")
	register_clcmd("chooseteam", "clcmd_join")
	
	register_clcmd("joinclass", "clcmd_joinclass")
	
	g_msgSendAudio = get_user_msgid("SendAudio");
	g_msgTextMsg = get_user_msgid("TextMsg");
	g_msgStatusIcon = get_user_msgid("StatusIcon");
	g_msgTeamInfo = get_user_msgid("TeamInfo");
	g_msgSayText = get_user_msgid("SayText");
	g_msgMoney = get_user_msgid("Money");
	
	register_message(get_user_msgid("ShowMenu"), "teammenu_Hook");
	register_message(get_user_msgid("VGUIMenu"), "teammenuVGUI_Hook");
	register_message(g_msgMoney, "fw_message_money");
	
	Game_HudSyncObj = CreateHudSyncObj();
	StatusValue_HudSyncObj = CreateHudSyncObj();
	
	fw_jbmm_itemadded = CreateMultiForward("jb_mm_itemadded", ET_CONTINUE, FP_CELL, FP_CELL)
	fw_jbmm_item_selected = CreateMultiForward("jb_mm_itemselected", ET_IGNORE, FP_CELL, FP_CELL)
	fw_lr_item_selected = CreateMultiForward("jb_lr_duel_selected", ET_CONTINUE, FP_CELL, FP_CELL)
	fw_lr_duel_started = CreateMultiForward("jb_lr_duel_started", ET_IGNORE, FP_CELL, FP_CELL, FP_CELL)
	fw_lr_duel_ended = CreateMultiForward("jb_lr_duel_ended", ET_IGNORE, FP_CELL, FP_CELL, FP_CELL)
	fw_shop_item_select_pre = CreateMultiForward("jb_shop_item_preselect", ET_CONTINUE, FP_CELL, FP_CELL)
	fw_shop_item_select_post = CreateMultiForward("jb_shop_item_postselect", ET_CONTINUE, FP_CELL, FP_CELL)
	fw_shop_item_bought = CreateMultiForward("jb_shop_item_bought", ET_IGNORE, FP_CELL, FP_CELL)
	fw_day_start = CreateMultiForward("jb_day_started", ET_IGNORE, FP_CELL)
	fw_day_ended = CreateMultiForward("jb_day_ended", ET_IGNORE, FP_CELL)
	fw_day_preselected = CreateMultiForward("jb_day_preselected", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL)
	fw_day_postselected = CreateMultiForward("jb_day_postselected", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL)
	fw_round_start = CreateMultiForward("jb_round_start", ET_IGNORE)
	fw_round_end = CreateMultiForward("jb_round_end", ET_IGNORE)
	fw_pretouch_wpnbox = CreateMultiForward("jb_pretouch_wpnbox", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL)
	fwd_teamhandling = CreateMultiForward("jb_team_join", ET_CONTINUE, FP_CELL)
	
	register_clcmd("say", "client_say_cmd", ADMIN_LEVEL_F)
	register_clcmd("say_team", "client_say_cmd", ADMIN_LEVEL_F)
	
	register_clcmd("jb_start_voteday", "clcmd_start_voteday", ADMIN_LEVEL_F)
	
	formatex(MODE, charsmax(MODE), "%s_v%s_By_%s", PLUGIN, VERSION, AUTHOR)
	register_cvar(MODE, "", FCVAR_SERVER|FCVAR_PROTECTED|FCVAR_SPONLY)
	
	for(new i = 0; i < sizeof CVARS_DATA; i++)
	{
		g_iCvar_identity[i] = register_cvar(CVARS_DATA[i][STR_CVARSNAME], CVARS_DATA[i][STR_CVARSVALUE]);
	}
	
	RegisterHam(Ham_Spawn, "player", "fw_player_spawned", 1)
	RegisterHam(Ham_Spawn, "player", "fw_player_spawning", 0)
	
	RegisterHam(Ham_Item_Deploy, "weapon_knife", "fw_knife_deploy", 1)
	
	RegisterHam(Ham_Touch, "weaponbox", "fw_touch_weaponbox", 0)
	RegisterHam(Ham_Touch, "armoury_entity", "fw_touch_weaponbox", 0)
	RegisterHam(Ham_Touch, "weapon_shield", "fw_touch_weaponbox", 0)
	
	RegisterHam(Ham_Killed, "player", "fw_player_killed_post", 1)
	
	for(new i = CSW_P228, sWpnname[32]; i <= CSW_P90; i++)
	{
		get_weaponname(i, sWpnname, charsmax(sWpnname))
		if(!get_weaponid(sWpnname)) continue;
		RegisterHam(Ham_Item_CanDeploy, sWpnname, "fw_wpn_deployed_pre")
	}
	
	RegisterHam(Ham_TraceAttack, "func_button", "fw_button_traceattack_post", 1)
	RegisterHam(Ham_Use, "func_button", "fw_button_use_pre", 0)
	RegisterHam(Ham_Use, "button_target", "fw_button_use_pre", 0)
	RegisterHam(Ham_Touch, "trigger_hurt", "fw_healing_use_pre", 0)
	RegisterHam(Ham_Use, "func_healthcharger", "fw_healing_use_pre", 0)
	
	formatex(MODE, charsmax(MODE), "%s_v%s", PLUGIN, VERSION)
	register_forward(FM_GetGameDescription, "fw_GetGameDescription")
	register_forward(FM_EmitSound, "fw_emitsound");
	
	register_logevent("fw_got_theBomb", 3, "2=Spawned_With_The_Bomb")
	
	g_iMaxplayers = get_maxplayers();
	g_lr_inprogress = -1;
	g_day_inprogress = -1;
	
	for(new j, i; j < TEAM_MAX; j++)
	{
		for(i = 0; i < g_iMaxplayers; i++)
		{
			g_iClass[i][j] = -1;
		}
	}
	
	// Languages Support...
	register_dictionary("jailbreak_langs.txt");
	
	// HUDMESSAGE...
	set_task(1.0, "Game_Hudmessage", TASK_HUDMESSAGE, _, _, "b")
}

public fw_healing_use_pre(ent)
{
	new sClassname[24];
	pev(ent, pev_classname, sClassname, charsmax(sClassname));
	
	if(equal(sClassname, "trigger_hurt") && pev(ent, pev_dmg) > 0)
	{
		return HAM_IGNORED;
	}
	
	if(g_day_inprogress > -1)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_HEALING_ONFUNDAYS]))
			return HAM_SUPERCEDE;
	}
	
	if(g_lr_inprogress > -1)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_HEALING_ONLR]))
			return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public fw_button_use_pre()
{
	if(g_day_inprogress > -1)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_BUTTONS_ONFUNDAYS]))
			return HAM_SUPERCEDE;
	}
	
	if(g_lr_inprogress > -1)
	{
		if(get_pcvar_num(g_iCvar_identity[CVAR_BLOCK_BUTTONS_ONLR]))
			return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public fw_GetGameDescription()
{
	forward_return(FMV_STRING, MODE)
	return (FMRES_SUPERCEDE);
}

public fw_message_money(msgid, dest, id)
{ 
	if(get_msg_argtype(1) == ARG_LONG)
	{
		set_msg_arg_int(1, ARG_LONG, user_cash[id]);
	}
}

public fw_player_killed_post(iVictim, iKiller, shouldgib)
{
	remove_flag(IsUserAlive,iVictim);
	
	if(g_lr_inprogress > -1)
	{
		if(((iKiller != g_iLRPrisoner && iKiller != g_iLRGuard) ||
			(iVictim != g_iLRPrisoner && iVictim != g_iLRGuard)) && is_user_connected(iKiller))
		{
			new sName[32], g_cash_amount; g_cash_amount = get_pcvar_num(g_iCvar_identity[CVAR_DUEL_LOST_CASH]);
			get_user_name(iKiller, sName, charsmax(sName))
			
			cprint_chat(0, _, "%L", LANG_PLAYER, "LR_LOOSE_CASH", sName, g_cash_amount)
			jb_set_user_cash(iKiller, jb_get_user_cash(iKiller)-g_cash_amount)
		}
		
		if(iVictim == g_iLRPrisoner || iVictim == g_iLRGuard)
		{
			_end_theduel();
		}
	}
	else if(g_day_inprogress > -1)
	{
		switch( ArrayGetCell(g_days_dayendtype, g_day_inprogress) )
		{
			case DAY_ONE_SURVIVOR: {
				if((get_prisonersnum(FLAG_ALIVE_ONLY) + get_guardsnum(FLAG_ALIVE_ONLY)) <= 1) TerminateRound( RoundEndType_TeamExtermination );
			}
			case DAY_GUARDS_VS_PRISONERS: { 
				if((get_prisonersnum(FLAG_ALIVE_ONLY) <= 1)) _end_theday();
			}
		}
	}
	
	if(get_prisonersnum(FLAG_ALIVE_ONLY) == 1 &&
		get_guardsnum(FLAG_ALIVE_ONLY) > 0 &&
		g_lr_inprogress == -1 && g_day_inprogress == -1)
	{
		g_lr_inprogress = -2;
		logevent_message("Last request is activated!")
		
		new winner = get_last_prisoner_alive();
		if(winner > 0)
		{
			Show_lastrequestmenu(winner);
			g_iLRPrisoner = winner;
		}
	}
	
	return HAM_IGNORED;
}

public fw_button_traceattack_post(entButton, attacker, Float:dmg, Float:direction[3], trace, bits)
{
	if( !(1 <= attacker <= g_iMaxplayers) || !check_flag(IsUserAlive,attacker) ) return;
	
	new weaponid = get_user_weapon(attacker);
	if(!weaponid) return;
	
	new team = fm_get_user_team(attacker);
	
	switch(get_pcvar_num(g_iCvar_identity[CVAR_BUTTON_ACTIVATION]))
	{ 
		case 0: return;
		case 1: if(dmg <= 0.0) return;
		case 2: if(weaponid != CSW_KNIFE) return;
		case 3: if(team != TEAM_PRISONERS) return;
		case 4: if(team != TEAM_GUARDS) return;
		case 5: if(team != TEAM_PRISONERS || weaponid != CSW_KNIFE) return;
		case 6: if(team != TEAM_GUARDS || weaponid != CSW_KNIFE) return;
	}
	
	new szWpname[24];
	get_weaponname(weaponid, szWpname, charsmax(szWpname));
	ExecuteHamB(Ham_Use, entButton, attacker , find_ent_by_owner(-1, szWpname, attacker), 2, 1.0);
}

public fw_wpn_deployed_pre(const iWpn)
{
	new id = get_pdata_cbase(iWpn, m_iWeaponOwner, WEAPON_LINUXDIFF)
	
	if(!g_user_wpns_blocked[id]) return HAM_IGNORED;
	
	new sClassname[32], Wpn
	pev(iWpn, pev_classname, sClassname, charsmax(sClassname))
	
	Wpn = cs_get_weapon_id(iWpn);
	
	if(check_flag(g_user_wpns_blocked[id], Wpn))
	{
		set_pev(id, pev_weapons, (pev(id,pev_weapons) & ~(1<<Wpn)));
		ExecuteHam(Ham_RemovePlayerItem,id,iWpn);
		ExecuteHam(Ham_Item_Kill, iWpn);
		SetHamReturnInteger(false);
		return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

stock const m_rgpPlayerItems_CWeaponBox[ 6 ] = { 34 , 35 , ... };

cs_get_weaponbox_type( iWeaponBox )
{
	new iWeapon
	for( new i = 0; i <= 5; i++ )
	{
		iWeapon = get_pdata_cbase( iWeaponBox, m_rgpPlayerItems_CWeaponBox[ i ], 4 )
		
		if( iWeapon > 0 ) return cs_get_weapon_id( iWeapon );
	}
	return 0
}

public fw_touch_weaponbox(entwpnbox, toucher)
{
	if(!(1 <= toucher <= g_iMaxplayers) || !check_flag(IsUserAlive,toucher))
		return HAM_IGNORED;
	
	static sClassname[32], iWpn;
	pev(entwpnbox, pev_classname, sClassname, charsmax(sClassname))
	
	if(equal(sClassname, "armoury_entity"))
		iWpn = cs_get_armoury_type(entwpnbox)
	else if(equal(sClassname, "weaponbox"))
		iWpn = cs_get_weaponbox_type(entwpnbox)
	else if(equal(sClassname, "weapon_", 7))
		iWpn = get_weaponid(sClassname);
	else return HAM_IGNORED;
	
	static bool:bBlock; bBlock = false;
	ExecuteForward(fw_pretouch_wpnbox, g_fw_return, entwpnbox, toucher, bBlock)
	
	if(g_fw_return > HAM_IGNORED)
	{
		return g_fw_return;
	}
	
	if((check_flag(g_user_wpns_blocked[toucher],iWpn) || bBlock))
	{
		return HAM_SUPERCEDE;
	}
	
	return HAM_IGNORED;
}

public clcmd_start_voteday(id, level, cid)
{
	if(!cmd_access(id, level, cid, 1))
	{
		cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
		return 0;
	}
	
	if(!Check_day_available(id))
	{
		console_print(id, "[ Jailbreak ] You can't start a voteday at the moment!")
		return PLUGIN_HANDLED;
	}
	
	Show_votedays_menu()
	
	new sName[32]
	get_user_name(id, sName, charsmax(sName))
	console_print(id, "[ Jailbreak ] You have started a voteday!")
	cprint_chat(0, _, "%L", LANG_PLAYER, "ADMIN_START_VOTEDAY", sName)
	
	new sAuthid[32], sTeam[16];
	get_user_authid(id, sAuthid, charsmax(sAuthid))
	get_user_team(id, sTeam, charsmax(sTeam))
	logevent_message("^"<%s><%d><%s><%s>^" Admin has started a voteday!", sName, get_user_userid(id), sAuthid, sTeam)
	
	return PLUGIN_HANDLED;
}

public fw_statusvalue(id)
{
	new iTeamRelation = read_data(1);
	new target = read_data(2);
	
	if(!target && iTeamRelation)
	{
		ClearSyncHud(id, StatusValue_HudSyncObj);
		return;
	}
	
	if((1 <= target <= g_iMaxplayers) && check_flag(IsUserAlive,target))
	if((1 <= target <= g_iMaxplayers) && check_flag(IsUserAlive,target))
	{
		new sName[32], iClassid = g_iClass[target][fm_get_user_team(target)];
		get_user_name(target, sName, charsmax(sName))
		
		if(fm_get_user_team(target) == fm_get_user_team(id) && jb_is_user_class_valid(id,iClassid) > 0)
		{
			new xArray[CLASSES_DATA];
			ArrayGetArray(g_classes_array, iClassid, xArray)
			set_hudmessage(100, 255, 100, -1.0, 0.62, 1, 6.0, 1.0, 0.1, 0.2, 4)
			ShowSyncHudMsg(id, StatusValue_HudSyncObj, "Name: %s^nHealth: %d^nCash: $%d^nClass: %s", sName, get_user_health(target), user_cash[target], xArray[CLASS_NAME])
		}
		else
		{
			set_hudmessage(100, 255, 100, -1.0, 0.62, 1, 6.0, 1.0, 0.1, 0.2, 4)
			ShowSyncHudMsg(id, StatusValue_HudSyncObj, "Name: %s^nHealth: %d^nCash: $%d", sName, get_user_health(target), user_cash[target])
		}
	}
}

public fw_emitsound(const entity, const channel, const sound[], Float:vol, Float:attn, flag, pitch)
{
	if(!is_user_connected(entity)) return FMRES_IGNORED;
	
	if(!check_flag(IsUserAlive,entity))
		return FMRES_IGNORED;
	
	new classid = g_iClass[entity][fm_get_user_team(entity)];
	
	if(jb_is_user_class_valid(entity, classid) <= 0 || get_user_weapon(entity) != CSW_KNIFE)
		return FMRES_IGNORED;
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	
	if(xArray[CLASS_KNIFE_SOUNDS][0] == EOS)
		return FMRES_IGNORED;
	
	for(new i, sSound[64]; i < sizeof knife_sounds; i++)
	{
		if(equal(sound[13], knife_sounds[i]))
		{
			formatex(sSound, charsmax(sSound), "%s%s", xArray[CLASS_KNIFE_SOUNDS], knife_sounds[i])
			emit_sound(entity, channel, sSound, vol, attn, flag, pitch);
			return FMRES_SUPERCEDE;
		}
	}
	return FMRES_IGNORED;
}

public fw_knife_deploy(const Knife)
{
	new id = get_pdata_cbase(Knife, m_iWeaponOwner, WEAPON_LINUXDIFF);
	new classid = g_iClass[id][fm_get_user_team(id)];
	
	if(!check_flag(IsUserAlive,id) || jb_is_user_class_valid(id,classid) <= 0 || cs_get_user_shield(id))
	{
		return HAM_IGNORED;
	}
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray)
	
	set_pev(id, pev_viewmodel2, xArray[CLASS_V_KNIFE_MDL])
	set_pev(id, pev_weaponmodel2, xArray[CLASS_P_KNIFE_MDL])
	
	return HAM_IGNORED;
}

public fw_got_theBomb()
{
	new sName[32], sText[64]
	read_logargv(0, sText, charsmax(sText))
	parse_loguser(sText, sName, charsmax(sName))
	
	new id = get_user_index(sName)
	
        message_begin(MSG_ONE_UNRELIABLE, g_msgStatusIcon, _, id) 
        write_byte(0)
        write_string("c4")
        message_end() 
	
	ham_strip_weapon(id, "weapon_c4")
	//strip_weapons(id)
	engclient_cmd(id, "weapon_knife")
}

public clcmd_joinclass(id)
{
	class_menu(id)
	return PLUGIN_HANDLED
}

public teammenuVGUI_Hook(iMsgid, dest, id)
{
	if(get_msg_arg_int(1) == 2)
	{
		set_task(0.01, "clcmd_join", id)
		return PLUGIN_HANDLED;
	}
	if(get_msg_arg_int(1) == 26 || get_msg_arg_int(1) == 27)
	{
		set_task(0.01, "class_menu", id)
		return PLUGIN_HANDLED;
	}
	return PLUGIN_CONTINUE;
}

public message_textmsg( msg_id, msg_dest, msg_entity )
{
	static message[3];
	get_msg_arg_string( 2, message, sizeof message - 1 );
	
	switch( message[1] )
	{
		// -- #CTs_Win ; #Terrorists_Win ; #Round_Draw
		case 'C', 'T', 'R' : return PLUGIN_HANDLED;
	}
	
	return PLUGIN_CONTINUE;
}

public message_sendaudio( msg_id, msg_dest, msg_entity )
{
	static message[10];
	get_msg_arg_string( 2, message, sizeof message - 1 );
	
	switch( message[7] )
	{
		// -- %!MRAD_terwin ; %!MRAD_ctwin ; %!MRAD_rounddraw
		case 'c', 't', 'r' : return PLUGIN_HANDLED;
	}
	
	return PLUGIN_CONTINUE;
}

public teammenu_Hook(iMsgid, dest, id)
{
	if(get_msg_argtype(4) != ARG_STRING)
		return PLUGIN_CONTINUE;
	
	static StrMessage[24]
	get_msg_arg_string(4, StrMessage, charsmax(StrMessage))
	
	// join team
	if(equal(StrMessage, "#Team_Select", strlen("#Team_Select")) || equal(StrMessage, "#IG_Team_Select", strlen("#IG_Team_Select")))
	{
		set_task(0.01, "clcmd_join", id)
		return PLUGIN_HANDLED;
	}
	if(equal(StrMessage, "#Terrorist_Select") || equal(StrMessage, "#CT_Select"))
	{
		set_task(0.01, "class_menu", id)
		return PLUGIN_HANDLED;
	}
	return PLUGIN_CONTINUE;
}

public client_connect(id)
{
	// change  to vgui menu..
	set_user_info(id, "_vgui_menus", "1")
	
	// load user cash
	//load_user_cash(id)
	
	g_iClass[id][TEAM_ANY] = -1;
	g_iClass[id][TEAM_SPECTATOR] = -1;
	g_iClass[id][TEAM_GUARDS] = -1;
	g_iClass[id][TEAM_PRISONERS] = -1;
	
	g_iNextClass[id] = -1;
}

public client_disconnected(id)
{
	// one of the duelers ran out!
	if(g_lr_inprogress != -1)
	{
		if(id == g_iLRGuard || id == g_iLRPrisoner)
		{
			_end_theduel()
		}
	}
	
	// save user cash...
	//save_user_cash(id)
	
	// remove flags...
	remove_flag(g_votedays_voted,id);
	remove_flag(g_has_avotedaymenu,id);
	remove_flag(IsUserAlive,id);
}


save_map_cells_button(target_button)
{
	g_cells_button = target_button;
	
	new szMapname[32], szStr[8]
	get_mapname(szMapname, charsmax(szMapname))
	
	num_to_str(target_button, szStr, charsmax(szStr))
	nvault_set(g_nvault_cells_button, szMapname, szStr)
}

public clcmd_join(id)
{
	set_pdata_int(id, 125, get_pdata_int(id, 125, 5) & ~(1<<8), 5)
	
	switch( fm_get_user_team(id) )
	{
		case TEAM_GUARDS:
		{
			if(g_iClass[id][TEAM_GUARDS] == -1)
			{
				class_menu(id)
			}
			else Show_jailbreakmenu(id)
		}
		case TEAM_PRISONERS:
		{
			if(g_iClass[id][TEAM_PRISONERS] == -1)
			{
				class_menu(id)
			}
			else Show_jailbreakmenu(id)
		}
		default:
		{
			join_menu(id)
		}
	}
	return PLUGIN_HANDLED;
}

get_ratio_left(Float:fRatio=1.0, team=TEAM_ANY, flag=FLAG_ALL)
{
	static p[32], num, connected_players;
	get_players(p, connected_players)
	
	switch( team )
	{
		case TEAM_PRISONERS: num = get_prisonersnum(flag)
		case TEAM_GUARDS: num = get_guardsnum(flag)
		case TEAM_SPECTATOR:
		{
			switch( flag )
			{
				case FLAG_ALL: get_players(p, num, "eh", "SPECTATOR")
				case FLAG_ALIVE_ONLY: get_players(p, num, "ahe", "SPECTATOR")
				case FLAG_DEAD_ONLY: get_players(p, num, "bhe", "SPECTATOR")
			}
		}
	}
	
	return clamp((floatround((connected_players * fRatio), floatround_tozero)-num), 0, g_iMaxplayers)
}

public join_menu(id)
{
	new iMenu = menu_create("\yJoin \rteam...", "join_menu_handle")
	
	new sText[64];
	
	new gratio = get_ratio_left(get_pcvar_float(g_iCvar_identity[CVAR_GRATIO])/100.0, TEAM_GUARDS, FLAG_ALL)
	new pratio = get_ratio_left(get_pcvar_float(g_iCvar_identity[CVAR_PRATIO])/100.0, TEAM_PRISONERS, FLAG_ALL)
	
	if(is_user_admin(id) && get_pcvar_num(g_iCvar_identity[CVAR_ADMIN_JOIN]))
	{
		gratio++
		pratio++
	}
	
	new g_return;
	ExecuteForward(fwd_teamhandling, g_return, id);
	
	switch( g_return )
	{
		case JB_BLOCK_JOIN_BOTH: { pratio = 0; gratio = 0; }
		case JB_BLOCK_JOIN_GUARDS: gratio = 0;
		case JB_BLOCK_JOIN_PRISONERS: pratio = 0;
	}
	
	const NO_ACCESS = (1<<26);
	
	pratio ? formatex(sText, charsmax(sText), "\rPrisoner's \w( Terrorist )"):formatex(sText, charsmax(sText), "Prisoner's ( Terrorist )")
	menu_additem(iMenu, sText, "1", pratio > 0 ? 0:NO_ACCESS)
	
	if((get_user_flags(id) & ADMIN_LEVEL_D) || (get_user_flags(id) & ADMIN_LEVEL_F)) // flag 'p' or 'r' required
	{
		gratio ? formatex(sText, charsmax(sText), "\rGuard's \w( Counter-terrorist )^n^n"):formatex(sText, charsmax(sText), "Guard's ( Counter-terrorist )^n^n")
		menu_additem(iMenu, sText, "2", gratio > 0 ? 0:NO_ACCESS)
	}

	formatex(sText, charsmax(sText), "\yJoin Spectator")
	menu_additem(iMenu, sText, "3")
	
	menu_display(id, iMenu)
}

public join_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sName[64], pAccess
	new sData[2], iCallback
	menu_item_getinfo(menu, item, pAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	
	if(contain(sName, "\d") != -1)
	{
		menu_destroy(menu)
		join_menu(id)
		return PLUGIN_HANDLED;
	}
	
	menu_destroy(menu)
	set_user_team(id, str_to_num(sData))
	return PLUGIN_HANDLED;
}

public class_menu(id)
{
	new iMenu = menu_create("\yChoose your \rclass...", "class_menu_handle")
	
	new sInfo[2], iTeam = fm_get_user_team(id), xlen = strlen(SZTEAMS[iTeam]);
	
	const NO_ACCESS = (1<<26);
	
	for(new i = 0, paccess, xArray[CLASSES_DATA]; i < g_iClasses; i++)
	{
		ArrayGetArray(g_classes_array, i, xArray)
		
		if(equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], xlen) || equali(SZTEAMS[TEAM_ANY], xArray[CLASS_TEAM], xlen))
		{
			paccess = ((get_user_flags(id) & xArray[CLASS_FLAGS]) || xArray[CLASS_FLAGS] == ADMIN_ALL) ? 0:NO_ACCESS;
			sInfo[0] = i;
			menu_additem(iMenu, xArray[CLASS_NAME], sInfo, paccess)
		}
	}
	
	menu_display(id, iMenu)
}

public class_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sName[32], pAccess;
	new sData[2], iCallback;
	menu_item_getinfo(menu, item, pAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	menu_destroy(menu);
	
	new xClassid = sData[0];
	
	if(!jb_is_user_class_valid(id, xClassid))
	{
		class_menu(id)
		return PLUGIN_HANDLED;
	}
	
	
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, xClassid, xArray)
	g_iNextClass[id] = -1;
	join_class(id, xClassid)
	
	// set user class model;
	jb_set_user_class_model(id)
	return PLUGIN_HANDLED;
}

stock set_user_team(id, team)
{
	switch( team )
	{
		case TEAM_GUARDS: engclient_cmd(id, "jointeam", "2")
		case TEAM_PRISONERS: engclient_cmd(id, "jointeam", "1")
		case TEAM_SPECTATOR: engclient_cmd(id, "jointeam", "6")
		case TEAM_ANY:
		{
			new sString[2]
			team = random_num(TEAM_PRISONERS, TEAM_GUARDS)
			num_to_str(team, sString, charsmax(sString))
			engclient_cmd(id, "jointeam", sString)
		}
	}
	
	// set user team...
	fm_set_user_team(id,team)
	
	static const TeamInfo[TEAM_MAX][] = 
	{ 
		"UNASSIGNED",
		"TERRORIST",
		"CT",
		"SPECTATOR" 
	};
	
	message_begin(MSG_ALL, g_msgTeamInfo, _, id);
	write_byte(id); 
	write_string(TeamInfo[team]); 
	message_end(); 
	
	if(check_flag(IsUserAlive,id))
	{
		user_kill(id, 1)
	}
}

stock strip_weapons(id)
{
	strip_user_weapons(id);
	ham_give_weapon(id, "weapon_knife");
}

// takes a weapon from a player efficiently
stock ham_strip_weapon(id, const weapon[])
{
	if(!equal(weapon,"weapon_",7)) return 0;
	
	new wId = get_weaponid(weapon);
	if(!wId) return 0;
	
	new wEnt = find_ent_by_owner(-1, weapon, id);
	if(!wEnt) return 0;	
	
	if(get_user_weapon(id) == wId) ExecuteHamB(Ham_Weapon_RetireWeapon,wEnt);
	
	if(!ExecuteHamB(Ham_RemovePlayerItem,id,wEnt)) return 0;
	ExecuteHamB(Ham_Item_Kill,wEnt);
	
	set_pev(id, pev_weapons, (pev(id,pev_weapons) & ~(1<<wId)));
	
	// this block should be used for Counter-Strike:
	if(wId == CSW_C4)
	{
		cs_set_user_plant(id, 0, 0);
		cs_set_user_bpammo(id, CSW_C4, 0);
	}
	else if((1<<wId) & ((1<<CSW_SMOKEGRENADE)|(1<<CSW_FLASHBANG)|(1<<CSW_HEGRENADE)))
	{
		cs_set_user_bpammo(id, wId, 0);
	}
	
	return 1;
}

// gives a player a weapon efficiently
stock ham_give_weapon(id, const weapon[])
{
	if(!equal(weapon, "weapon_",7)) return 0;
	
	new wEnt = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString, weapon));
	if(!pev_valid(wEnt)) return 0;
	
	set_pev(wEnt,pev_spawnflags, SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn, wEnt);
	
	if(!ExecuteHamB(Ham_AddPlayerItem, id, wEnt))
	{
		if(pev_valid(wEnt)) set_pev(wEnt,pev_flags, pev(wEnt,pev_flags)|FL_KILLME);
		return 0;
	}
	
	ExecuteHamB(Ham_Item_AttachToPlayer,wEnt,id)
	return 1;
}

public fw_player_spawning(id)
{
	new iTeam = fm_get_user_team(id),
	classid = g_iClass[id][iTeam],
	nextclassid = g_iNextClass[id];
	
	if(jb_is_user_class_valid(id,classid) <= 0) classid = -1;
	if(jb_is_user_class_valid(id,nextclassid) <= 0) nextclassid = -1;
	
	if(classid == -1 && nextclassid == -1)
	{
		nextclassid = find_available_class(id);
	}
	
	if(nextclassid > -1)
	{
		new xArray[CLASSES_DATA];
		join_class(id, nextclassid)
		ArrayGetArray(g_classes_array, nextclassid, xArray)
		
		g_iNextClass[id] = -1;
		
		// set user class model;
		jb_set_user_class_model(id)
	}
	
	if((g_iLRGuard == id || g_iLRPrisoner == id) && g_lr_inprogress != -1)
	{
		_end_theduel()
	}
}

find_available_class(id)
{
	new iTeam = fm_get_user_team(id);
	for(new i, xArray[CLASSES_DATA], teamlen = strlen(SZTEAMS[iTeam]); i < g_iClasses; i++)
	{
		ArrayGetArray(g_classes_array, i, xArray);
		
		if(equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], teamlen))
		{
			if((get_user_flags(id) & xArray[CLASS_FLAGS]) || !xArray[CLASS_FLAGS])
			{
				return i;
			}
		}
	}
	
	return -1;
}

public join_class(id, classid)
{
	new iTeam = fm_get_user_team(id)
	
	for(new i; i < TEAM_MAX; i++)
	{
		g_iClass[id][i] = -1;
	}
	
	g_iClass[id][iTeam] = classid;
	engclient_cmd(id, "joinclass", "5")
}

public fw_player_spawned(id)
{
	if(!is_user_alive(id))
		return
	
	set_flag(IsUserAlive,id);
	
	if(get_prisonersnum(FLAG_ALIVE_ONLY) > 1 && g_lr_inprogress != -1)
	{
		_end_theduel()
	}
	
	// Reset user rendernig
	set_user_rendering(id)
	
	// strip user weapons
	strip_weapons(id)
	
	new iTeam = fm_get_user_team(id),
	iClass = g_iClass[id][iTeam];
	
	// if its not a valid class...
	if(jb_is_user_class_valid(id,iClass) <= 0)
		return;
	
	// set user class model;
	jb_set_user_class_model(id)
	
	if(Check_weapons_available(id))
	{
		new xArray[CLASSES_DATA];
		ArrayGetArray(g_classes_array, iClass, xArray)
		
		switch( iTeam )
		{
			case TEAM_GUARDS:
			{
				switch( get_pcvar_num(g_iCvar_identity[CVAR_GGIVE_WPNS]) )
				{
					case 1: Show_weaponsmenu(id, xArray[CLASS_PRIMWEAPONS], "\r[ \yJailbreak \r] \wChoose your primary weapon..", "primary_wpnshandle")
					case 2:
					{
						give_weapons(id, xArray[CLASS_PRIMWEAPONS], ',')
						give_weapons(id, xArray[CLASS_SECWEAPONS], ',')
					}
				}
			}
			case TEAM_PRISONERS:
			{
				switch( get_pcvar_num(g_iCvar_identity[CVAR_PGIVE_WPNS]) )
				{
					case 1: Show_weaponsmenu(id, xArray[CLASS_PRIMWEAPONS], "\r[ \yJailbreak \r] \wChoose your primary weapon..", "primary_wpnshandle")
					case 2:
					{
						give_weapons(id, xArray[CLASS_PRIMWEAPONS], ',')
						give_weapons(id, xArray[CLASS_SECWEAPONS], ',')
					}
				}
			}
		}
	}
	
	if(g_day_inprogress == -2) // if its a voteday event...
	{
		set_user_godmode(id, 1) // set user godmode
	}
}

new bool:bRoundStart = false;

public round_start()
{
	if(bRoundStart) return;
	
	bRoundStart = true;
	
	remove_task(TASK_VOTEDAY_TIMER);
	remove_task(TASK_LR_TIMER);
	
	if(g_lr_inprogress != -1)
	{
		_end_theduel()
	}
	
	if(g_day_inprogress != -1)
	{
		_end_theday()
	}
	
	logevent_message("Round has started!")
	
	ExecuteForward(fw_round_start, g_fw_return)
	
	if(get_prisonersnum(FLAG_ALIVE_ONLY) == 1 &&
		get_guardsnum(FLAG_ALIVE_ONLY) > 0 &&
		g_lr_inprogress == -1 && g_day_inprogress == -1)
	{
		g_lr_inprogress = -2;
		logevent_message("Last request is activated!")
		
		new winner = get_last_prisoner_alive();
		if(winner > 0)
		{
			Show_lastrequestmenu(winner);
			g_iLRPrisoner = winner;
		}
	}
	else
	{
		set_task(0.5, "Check_today_isfunday");
	}
	
	bRoundStart = false;
}

public Check_today_isfunday()
{
	if(!Check_day_available(0, false))
	{
		return true;
	}
	
	new sString[64], sOutput[MAX_DAYS][10], i, j
	get_pcvar_string(g_iCvar_identity[CVAR_FUNDAYS], sString, charsmax(sString))
	str_explode(sString, ',', sOutput, MAX_DAYS, charsmax(sOutput[]))
	
	for(j = 0; j < MAX_DAYS; j++)
	{
		if(equali(sDays[iToday], sOutput[j]))
		{
			i = true;
			Show_votedays_menu()
			break;
		}
	}
	
	if(!i)
	{
		return false;
	}
	
	new players[32], num
	get_players(players, num, "a")
	
	for(i = 0; i < num; i++)
	{
		j = players[i]
		set_entity_flags(j, FL_FROZEN, 1)
	}
	
	return true;
}

// native jb_end_theduel()
public _end_theduel()
{
	if(g_lr_inprogress <= -1)
	{
		if(g_lr_inprogress == -2)
		{
			logevent_message("Last request is deactivated!");
			g_lr_inprogress = -1;
		}
		
		return 0;
	}
	
	g_user_wpns_blocked[g_iLRPrisoner] = 0;
	g_user_wpns_blocked[g_iLRGuard] = 0;
	
	remove_attachment_fromplayer(g_iLRPrisoner)
	remove_attachment_fromplayer(g_iLRGuard)
	
	remove_task(g_iLRPrisoner+TASK_BEACON)
	remove_task(g_iLRGuard+TASK_BEACON)
	remove_task(TASK_LR_TIMER)
	
	ExecuteForward(fw_lr_duel_ended, g_fw_return, g_iLRPrisoner, g_iLRGuard, g_lr_inprogress)
	g_iLRPrisoner = 0;
	g_iLRGuard = 0;
	g_lr_inprogress = -1;
	
	return 1;
}

get_last_prisoner_alive()
{
	new players[32], pnum
	get_players(players, pnum, "ache", "TERRORIST")
	
	return (pnum == 1) ? players[0]:0;
}

public round_end()
{
	// pass one day forwad when round end
	switch(iToday)
	{
		case DAY_SAT: iToday = DAY_SUN
		case DAY_SUN: iToday = DAY_MON
		case DAY_MON: iToday = DAY_TUE
		case DAY_TUE: iToday = DAY_WED
		case DAY_WED: iToday = DAY_THU
		case DAY_THU: iToday = DAY_FRI
		case DAY_FRI: iToday = DAY_SAT
	}
	
	remove_task(TASK_VOTEDAY_TIMER);
	remove_task(TASK_LR_TIMER);

	if(g_lr_inprogress != -1)
	{
		_end_theduel()
	}
	
	if(g_day_inprogress != -1)
	{
		_end_theday()
	}
	
	ExecuteForward(fw_round_end, g_fw_return)
	
	logevent_message("Round ended!")
	
	// block win messages & audio...
	if(fwMessage_sendaudio > 0) unregister_message(fwMessage_sendaudio, g_msgSendAudio); fwMessage_sendaudio = 0;
	if(fwMessage_textmsg > 0) unregister_message(fwMessage_textmsg, g_msgTextMsg); fwMessage_textmsg = 0;
	
	bRoundStart = false;
}

public Game_Hudmessage()
{
	static sBuffer[196], guards, prisoners;
	guards = get_guardsnum(FLAG_ALIVE_ONLY);
	prisoners = get_prisonersnum(FLAG_ALIVE_ONLY);
	
	if(g_day_inprogress > -1)
	{
		static SDayname[32];
		ArrayGetString(g_days_itemname, g_day_inprogress, SDayname, charsmax(SDayname))
		formatex(sBuffer, charsmax(sBuffer), "%s", SDayname)
		
		if(g_day_length > 0.0)
		{
			formatex(SDayname, charsmax(SDayname), "^nTime-Left: %1.f", g_day_length)
			add(sBuffer, charsmax(sBuffer), SDayname)
		}
	}
	else if(g_lr_inprogress > -1)
	{
		static SDuelname[32];
		ArrayGetString(g_lr_itemname, g_lr_inprogress, SDuelname, charsmax(SDuelname))
		static SGname[32], SPname[32];
		
		get_user_name(g_iLRGuard, SGname, charsmax(SGname))
		get_user_name(g_iLRPrisoner, SPname, charsmax(SPname))
		formatex(sBuffer, charsmax(sBuffer), "Day %s^n\
		Guard(s): %d  || Prisoner(s): %d^n\
		%s^n\
		Guard %s: %d HP^n\
		Prisoner %s: %d HP", sDays[iToday], guards, prisoners, SDuelname,
		SGname, get_user_health(g_iLRGuard), SPname, get_user_health(g_iLRPrisoner))
	}
	else
	{
		formatex(sBuffer, charsmax(sBuffer), "Day %s^nGuard(s): %d  || Prisoner(s): %d", sDays[iToday], guards, prisoners)
	}
	
	set_hudmessage(0, 210, 0, -1.0, 0.05, 0, 3.0, 0.999, 1.5, 1.0, 4)
	ShowSyncHudMsg(0, Game_HudSyncObj, sBuffer)
}

get_guardsnum(flags=FLAG_ALL)
{
	new gnum, g[32]
	
	switch( flags )
	{
		case FLAG_ALL: get_players(g, gnum, "eh", "CT") // alive & dead guards
		case FLAG_ALIVE_ONLY: get_players(g, gnum, "aeh", "CT") // alive guards
		case FLAG_DEAD_ONLY: get_players(g, gnum, "beh", "CT") // dead guards
		default: gnum = -1
	}
	
	return gnum
}

get_prisonersnum(flags=FLAG_ALL)
{
	new pnum, p[32]
	
	switch( flags )
	{
		case FLAG_ALL: get_players(p, pnum, "eh", "TERRORIST") // alive & dead prisoners
		case FLAG_ALIVE_ONLY: get_players(p, pnum, "aeh", "TERRORIST") // alive prisoners
		case FLAG_DEAD_ONLY: get_players(p, pnum, "beh", "TERRORIST") // dead prisoners
		default: pnum = -1
	}
	
	return pnum
}

Show_jailbreakmenu(id)
{
	new sBuf[64], paccess;
	
	formatex(sBuf, 63, "\r[-\yJailBreak\r-] \yMain Menu^n")
	new iMenu = menu_create(sBuf, "jailbreakmenu_handle")
	
	if(fm_get_user_team(id) == TEAM_PRISONERS)
	{
		paccess = Check_lr_available(id, false) ? 0:(1<<26);
		formatex(sBuf, charsmax(sBuf), "%sLast Request!^n", !paccess ? "\r":"\d")
		menu_additem(iMenu, sBuf, "LREQUEST", paccess)
	}
	
	paccess = Check_shop_available(id, false) ? 0:(1<<26);
	formatex(sBuf, charsmax(sBuf), "%sShop menu!",  !paccess ? "\y":"\d")
	menu_additem(iMenu, sBuf, "SHOP", paccess)
	
	if(get_user_flags(id) & ADMIN_IMMUNITY) //flag a required
	{
		paccess = Check_day_available(id, false) ? 0:(1<<26);
		formatex(sBuf, charsmax(sBuf), "%sDay's menu!", !paccess ? "\y":"\d")
		menu_additem(iMenu, sBuf, "DAYS", paccess)
	}
	new sItemname[32], sItemdata[2], iItemaccess, iItemteam
	
	for(new i = 0; i < g_jbmm_items; i++)
	{
		iItemteam = ArrayGetCell(g_jbmm_itemteam, i)
		
		if((iItemteam != fm_get_user_team(id)) &&  iItemteam != TEAM_ANY)
		{
			continue
		}
		
		ArrayGetString(g_jbmm_itemname, i, sItemname, charsmax(sItemname))
		iItemaccess = ArrayGetCell(g_jbmm_itemaccess, i)
		
		ExecuteForward(fw_jbmm_itemadded, g_fw_return, id, i)
		
		switch( g_fw_return )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				iItemaccess = (1<<26);
				formatex(sBuf, charsmax(sBuf), "\d%s", sItemname)
			}
			default: formatex(sBuf, charsmax(sBuf), "\y%s", sItemname)
		}
		
		num_to_str(i, sItemdata, charsmax(sItemdata))
		menu_additem(iMenu, sBuf, sItemdata, iItemaccess)
	}
	
	menu_addtext(iMenu, "^n\yHere you can change team!", 0)
	menu_additem(iMenu, "\yChange \rteam!", "JOIN")
	
	menu_setprop(iMenu, MPROP_NUMBER_COLOR, "\w")
	menu_display(id, iMenu)
}

public jailbreakmenu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return
	}
	
	new sData[10], sName[64], iCallback, iAccess
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	new itemid = str_to_num(sData)
	
	// destroyin the menu..
	menu_destroy(menu)
	
	if(contain(sName, "\d") != -1)
	{
		Show_jailbreakmenu(id)
		return
	}
	if(equal(sData, "SHOP"))
	{
		//shop_menu(id)
		client_cmd(id, "jb_shop")
		return;
	}
	if(equal(sData, "DAYS"))
	{
		days_menu(id)
		return;
	}
	if(equal(sData, "JOIN"))
	{
		join_menu(id);
		return;
	}
	if(equal(sData, "LREQUEST"))
	{
		Show_lastrequestmenu(id)
		return;
	}
	
	ExecuteForward(fw_jbmm_item_selected, g_fw_return, id, itemid)
}


// register_jailbreak_mmitem(const name[], access, team)
public _register_jailbreak_mmitem(plugin, argc)
{
	if(argc != 3) return -2;
	
	new item_name[32], item_access, item_team
	get_string(1, item_name, charsmax(item_name))
	item_access = get_param(2);
	item_team = get_param(3);
	
	if(strlen(item_name) < 3)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item name is too short!", plugin, 1)
		return -1;
	}
	if(!(TEAM_PRISONERS <= item_team <= TEAM_SPECTATOR) && item_team != TEAM_ANY )
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item team is not defined!", plugin, 4)
		return -1;
	}
	if(get_itemid_inarray_bystring(item_name, g_jbmm_itemname) > -1)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item with this name is already registered!", plugin, 1)
		return -1;
	}
	
	ArrayPushString(g_jbmm_itemname, item_name)
	ArrayPushCell(g_jbmm_itemaccess, item_access)
	ArrayPushCell(g_jbmm_itemteam, item_team)
	
	g_jbmm_items ++
	return g_jbmm_items-1
}

public Show_lastrequestmenu(id)
{
	if(!Check_lr_available(id, true))
	{
		return
	}
	
	if(!g_lr_items)
	{
		log_amx("There is no items in the API jailbreak lastrequest menu.")
		return
	}
	
	new sBuf[64]
	
	formatex(sBuf, 63, "\r[-\yLast Request\r-] \yMenu^n\wWhat are your demands \r!?")
	new iMenu = menu_create(sBuf, "lastrequestmenu_handle")
	
	new sItemname[32], sItemdata[2], iItemaccess
	
	for(new i; i < g_lr_items; i++)
	{
		ArrayGetString(g_lr_itemname, i, sItemname, charsmax(sItemname))
		iItemaccess = ArrayGetCell(g_lr_itemaccess, i)
		
		formatex(sBuf, charsmax(sBuf), "%s%s", (get_user_flags(id) & iItemaccess) ? "\r":"", sItemname)
		num_to_str(i, sItemdata, charsmax(sItemdata))
		menu_additem(iMenu, sBuf, sItemdata, iItemaccess)
	}
	
	menu_display(id, iMenu)
}

public lastrequestmenu_handle(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	if(!Check_lr_available(id))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sData[2], sName[64], iCallback, iAccess
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sName, charsmax(sName), iCallback)
	new itemid = str_to_num(sData)
	
	menu_destroy(menu)
	
	ExecuteForward(fw_lr_item_selected, g_fw_return, id, itemid)
	
	if(g_fw_return < JB_LR_OTHER_MENU)
	{
		Show_playersmenu(id, "\r[-\yLast Request\r-]^nChoose you'r target!", "lrmenu_handle2", sData, iAccess, TEAM_GUARDS, FLAG_ALIVE_ONLY)
	}
	
	return PLUGIN_HANDLED;
}

public _lr_show_targetsmenu(plugin, argc)
{
	new id = get_param(1), iDuelid = get_param(2), iAccess = get_param(3);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: Player #%d is not connected!", id)
		return;
	}
	
	if(!(0 <= iDuelid < g_lr_items))
	{
		log_error(AMX_ERR_NATIVE, "Error: Duel id #%d is out of range!", iDuelid)
		return;
	}
	
	new sData[10]
	num_to_str(iDuelid, sData, charsmax(sData))
	Show_playersmenu(id, "\r[-\yLast Request\r-]^nChoose you'r target!", "lrmenu_handle2", sData, iAccess, TEAM_GUARDS, FLAG_ALIVE_ONLY)
}

public lrmenu_handle2(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	if(!Check_lr_available(id))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sPlayername[32], sData[2]
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sPlayername, charsmax(sPlayername), iCallback)
	
	menu_destroy(menu)
	
	new player = find_player("af", sPlayername)
	new itemid = str_to_num(sData)
	
	new param[5]; param[3] = 200
	
	g_iLRPrisoner = id;
	g_iLRGuard = player;
	
	param[0] = 255;
	set_task(1.0, "player_beacon", id+TASK_BEACON, param, charsmax(param), "b")
	param[0] = 0; param[2] = 255;
	set_task(1.0, "player_beacon", player+TASK_BEACON, param, charsmax(param), "b")
	
	attach_sprite_toplayer(id, red_duelSpr, 99999)
	attach_sprite_toplayer(player, blue_duelSpr, 99999)
	
	strip_weapons(id)
	strip_weapons(player)
	
	set_user_health(id, 100)
	set_user_health(player, 100)
	
	g_lr_inprogress = itemid;
	
	new sDuelname[32];
	ArrayGetString(g_lr_itemname, itemid, sDuelname, charsmax(sDuelname))
	
	new sAuthid[32], sAuthid2[32], sTeam[16], sTeam2[16], szName[32];
	get_user_name(id, szName, charsmax(szName))
	get_user_authid(id, sAuthid, charsmax(sAuthid));
	get_user_authid(player, sAuthid2, charsmax(sAuthid2));
	get_user_team(id, sTeam, charsmax(sTeam));
	get_user_team(player, sTeam2, charsmax(sTeam2));
	logevent_message("^"<%s><%d><%s><%s>^" VS ^"<%s><%d><%s><%s>^" in ^"%s^" Last-request Duel!",
	szName, get_user_userid(id), sAuthid, sTeam,
	sPlayername, get_user_userid(player), sAuthid2, sTeam2, sDuelname)
	
	set_task(1.0, "LR_TIMER", TASK_LR_TIMER, _,_, "a", ((g_votedays_timer=clamp(get_pcvar_num(g_iCvar_identity[CVAR_LR_TIMER]), 0, 15)) + 1))
	return PLUGIN_HANDLED;
}

public LR_TIMER(taskid)
{
	if(g_lr_inprogress < 0)
	{
		remove_task(taskid);
		return;
	}
	
	new sDuelname[32], szName[32], szPName[32];
	ArrayGetString(g_lr_itemname, g_lr_inprogress, sDuelname, charsmax(sDuelname))
	get_user_name(g_iLRGuard, szName, charsmax(szName))
	get_user_name(g_iLRPrisoner, szPName, charsmax(szPName))
	
	set_hudmessage(0, 255, 0, -1.0, 0.35, 1, 1.0, 1.0, _, _, -1)
	show_hudmessage(0, "[%s]^n%s Vs %s^n%d", sDuelname, szName, szPName, g_votedays_timer)
	
	if(!g_votedays_timer)
	{
		ExecuteForward(fw_lr_duel_started, g_fw_return, g_iLRPrisoner, g_iLRGuard, g_lr_inprogress);
		remove_task(taskid);
		return;
	}
	
	g_votedays_timer--;
}

public player_beacon(param[], taskid)
{
	new id = taskid - TASK_BEACON
	
	if(!check_flag(IsUserAlive,id) || g_lr_inprogress <= -1)
	{
		remove_task(taskid)
		return
	}
	
	emit_sound(id, CHAN_AUTO, BEACON_SOUND, VOL_NORM, ATTN_NORM, 0, PITCH_HIGH)
	
	new iOrigin[3]
	get_user_origin(id, iOrigin)
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY, iOrigin, id)
	write_byte(TE_BEAMCYLINDER)	// TE id
	write_coord(iOrigin[0])	 	// x
	write_coord(iOrigin[1])		// y
	write_coord(iOrigin[2]-20)	// z
	write_coord(iOrigin[0]+20)    	// x axis
	write_coord(iOrigin[1]+20)    	// y axis
	write_coord(iOrigin[2]+200)	// z axis
	write_short(beaconSpr)		// sprite
	write_byte(1)			// startframe   
	write_byte(10)			// framerate   
	write_byte(3)			// life
	write_byte(10)  		// width
	write_byte(10)   		// noise  
	write_byte(param[0])  		// red  
	write_byte(param[1])   		// green
	write_byte(param[2]) 		// blue
	write_byte(param[3])		// brightness
	write_byte(0)			// speed
	message_end()
}

remove_attachment_fromplayer(plr)
{
	message_begin(MSG_ALL, SVC_TEMPENTITY);
	write_byte(TE_KILLPLAYERATTACHMENTS);
	write_byte(plr);
	message_end();
}

attach_sprite_toplayer(plr, mindex, life)
{
	message_begin(MSG_ALL, SVC_TEMPENTITY)
 	write_byte(TE_PLAYERATTACHMENT)
 	write_byte(plr)
 	write_coord(80)
 	write_short(mindex)
 	write_short(life * 10 )
	message_end()
}

Show_playersmenu(id, const title[], const handler[], sInfo[], iAccess=0, plrteam=TEAM_ANY, flag=FLAG_ALL)
{
	new players[32], pnum, player, i, sPlayername[32]
	
	switch( flag )
	{
		case FLAG_ALL: get_players(players, pnum, "h")
		case FLAG_ALIVE_ONLY: get_players(players, pnum, "ah")
		case FLAG_DEAD_ONLY: get_players(players, pnum, "bh")
	}
	
	new iMenu = menu_create(title, handler)
	
	for( i = 0; i < pnum; i++ )
	{
		player = players[i];
		
		if((plrteam != fm_get_user_team(player) && plrteam != TEAM_ANY) || id == player)
		{
			continue
		}
		
		get_user_name(player, sPlayername, charsmax(sPlayername))
		menu_additem(iMenu, sPlayername, sInfo, iAccess)
	}
	
	menu_setprop(iMenu, MPROP_NUMBER_COLOR, "\y")
	menu_display(id, iMenu)
}

bool:Check_lr_available(id, bool:bMsg=false)
{
	if(g_lr_inprogress > -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS")
		return false;
	}
	if(g_day_inprogress != -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "DAY_INPROGRESS")
		return false;
	}
	if(!check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_NOT_ALIVE")
		return false;
	}
	if(get_user_team(id) != TEAM_PRISONERS)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_PRISONERS_ONLY")
		return false;
	}
	if(get_prisonersnum(FLAG_ALIVE_ONLY) > 1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_LR_LAST_PRISONER_ONLY")
		return false;
	}
	if(get_guardsnum(FLAG_ALIVE_ONLY) == 0)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_LR_NO_GUARDS")
		return false;
	}
	
	return true;
}

// native register_jailbreak_lritem(const name[], iAccess)
public _register_jailbreak_lritem(plugin, argc)
{
	if(argc == 0) // no args dedicated...
		return -1
	
	new sItem[64]
	get_string(1, sItem, charsmax(sItem))
	new iAccess = get_param(2)
	
	if(strlen(sItem) < 5)
	{
		formatex(sItem, charsmax(sItem), "LR_INVAILD_ITEM_NAME")
	}
	
	ArrayPushString(g_lr_itemname, sItem)
	ArrayPushCell(g_lr_itemaccess, iAccess)
	
	g_lr_items++
	return g_lr_items-1
}

public _get_current_duel(plugin, argc)
{
	set_param_byref(1, g_iLRGuard)
	set_param_byref(2, g_iLRPrisoner)
	
	return g_lr_inprogress
}

// native jb_get_duel_name(iDuelid, sName[], iLen)
public _get_duel_name(plugin, argc)
{
	new iDuelid = get_param(1)
	
	if(0 > iDuelid || g_lr_items <= iDuelid)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Duel id #%d", iDuelid)
		return 0;
	}
	
	new sDuelname[32]
	ArrayGetString(g_lr_itemname, iDuelid, sDuelname, charsmax(sDuelname))
	set_string(2, sDuelname, get_param(3))
	
	return 1;
}

// native jb_get_duels_registered()
public _get_duels_registered(plugin, argc)
{
	return g_lr_items
}

// native jb_get_duelid_byname(const duelname[])
public _get_duelid_byname(plugin, argc)
{
	new sDuelname[32]
	get_string(1, sDuelname, charsmax(sDuelname))
	
	return (get_itemid_inarray_bystring(sDuelname, g_lr_itemname));
}

// native get current day...
public _get_current_day()
{
	return g_day_inprogress
}


public client_say_cmd(id, level, cid)
{
	new sString[96]
	read_args(sString, charsmax(sString))
	remove_quotes(sString)
	
	new sOutput[4][16], userid, sName[32], iAmount
	str_explode(sString, ' ', sOutput, 4, 15)
	
	if(equali(sOutput[0], "/class") || equali(sOutput[0], "!class"))
	{
		class_menu(id)
		return 1;
	}
	if(equali(sOutput[0], "/voteday") || equali(sOutput[0], "/vd"))
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		if(!Check_day_available(id, true))
		{
			return 0;
		}
		
		Show_votedays_menu()
		
		get_user_name(id, sName, charsmax(sName))
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_START_VOTEDAY", sName)
		return 1;
	}
	if(equali(sOutput[0], "/eday") || equali(sOutput[0], "/endtheday") || equali(sOutput[0], "/endday"))
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		if(g_day_inprogress <= -1)
		{
			cprint_chat(id, _, "%L", id, g_day_inprogress == -1 ? "DAY_NOT_INPROGRESS":"VOTEDAY_INPROGRESS");
			return 0;
		}
		
		new sAuthid[32], sTeam[16], sDayname[32];
		get_user_name(id, sName, charsmax(sName))
		get_user_authid(id, sAuthid, charsmax(sAuthid))
		get_user_team(id, sTeam, charsmax(sTeam))
		ArrayGetString(g_days_itemname, g_day_inprogress, sDayname, charsmax(sDayname))
		logevent_message("^"<%s><%d><%s><%s>^" Admin has ended the ^"%s^"", sName, get_user_userid(id), sAuthid, sTeam, sDayname)
		
		_end_theday()
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_END_DAY", sName)
		
		return 1;
	}
	if(equali(sOutput[0], "/eduel") || equali(sOutput[0], "/endtheduel") || equali(sOutput[0], "/endduel"))
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		if(g_lr_inprogress <= -1)
		{
			cprint_chat(id, _, "%L", id, "LR_NOT_INPROGRESS");
			return 0;
		}
		
		_end_theduel()
		get_user_name(id, sName, charsmax(sName))
		cprint_chat(0, 'n', "%L", "LANG_PLAYER", "ADMIN_END_LR", sName)
		return 1;
	}
	if(equali(sOutput[0], "/day") || equali(sOutput[0], "/dm"))
	{
		days_menu(id); return 1;
	}
	if(equali(sOutput[0], "/open") || equali(sOutput[0], "/close"))
	{
		
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		else 
		{
			new bool:gOpen = equali(sOutput[0], "/open") ? true:false
			
			new sAuthid[32], sTeam[16];
			get_user_name(id, sName, charsmax(sName))
			get_user_authid(id, sAuthid, charsmax(sAuthid))
			get_user_team(id, sTeam, charsmax(sTeam))
			
			logevent_message("^"<%s><%d><%s><%s>^" Admin has ^"%s^" the Cells!", sName, get_user_userid(id), sAuthid, sTeam, gOpen ? "opened":"closed")
			
			jb_cells(gOpen);
			cprint_chat(0, _, "%L", LANG_PLAYER, "COMMAND_OPEN_CELLS", sName, gOpen ? "^4opened^1":"^3closed^1")
		}
		
		return 1;
	}
	if(equali(sOutput[0], "/lr") || equali(sOutput[0], "/lastrequest"))
	{
		Show_lastrequestmenu(id); return 1;
	}
	if(equali(sOutput[0], "/transfer") || equali(sOutput[0], "/trans"))
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		
		userid = cmd_target(id, sOutput[1], CMDTARGET_ALLOW_SELF)
		
		if(sOutput[1][0] == '@') userid = true;
		
		new xTeam, szxTeam[32];
		switch( sOutput[userid ? 2:1][0] )
		{
			case 'C' , 'c', 'G', 'g': {
				xTeam = TEAM_GUARDS
				formatex(szxTeam, charsmax(szxTeam), "Counter-terrorist")
			}
			case 'T' , 't', 'P', 'p': {
				xTeam = TEAM_PRISONERS
				formatex(szxTeam, charsmax(szxTeam), "terrorist")
			}
			case 'S' , 's': {
				xTeam = TEAM_SPECTATOR
				formatex(szxTeam, charsmax(szxTeam), "spectators")
			}
			default: {
				cprint_chat(id, 'n', "%L", id, "COMMAND_FAILED_TRANSFER")
				return 0
			}
		}
		
		switch( sOutput[1][0] )
		{
			case '@':
			{
				new players[32], num, team[32]
				
				switch( sOutput[1][1] )
				{
					case 'C' , 'c': {
						get_players(players, num, "he", "CT")
						formatex(team, charsmax(team), "Counter-terrorist")
					}
					case 'T' , 't': {
						get_players(players, num, "he", "TERRORIST")
						formatex(team, charsmax(team), "terrorist")
					}
					case 'S' , 's': {
						get_players(players, num, "he", "SPECTATOR")
						formatex(team, charsmax(team), "spectators")
					}
					case 'A' , 'a': {
						get_players(players, num, "h")
						formatex(team, charsmax(team), "all players")
					}
					default: {
						cprint_chat(id, 'n', "%L", id, "COMMAND_FAILED_TRANSFER")
						return 0
					}
				}
				
				for(new i = 0; i < num; i++)
				{
					userid = players[ i ]
					
					set_user_team(userid, xTeam)
				}
				
				get_user_name(id, sName, charsmax(sName))
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TRANSFERING_TEAM", sName, team, szxTeam)
				return 1
			}
			default:
			{
				if(!is_user_connected(userid))
				{
					userid = id
				}
			}
		}
		
		set_user_team(userid, xTeam)
		get_user_name(userid, sOutput[1], charsmax(sOutput[]))
		get_user_name(id, sName, charsmax(sName))
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_TRANSFERING_PLAYER", sName, sOutput[1], szxTeam)
		return 1
	}
	if(equali(sOutput[0], "/set")) // health, armour, noclip, godmode, gravity, speed, flash, weapon, ammo
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		
		if(equali(sOutput[1], "health") || equali(sOutput[1], "hp"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
						return 0;
					}
					
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "all players")
						}
						default: {
							cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
							return 0
						}
					}
					
					new iColors[3]; 
					
					for(new i = 0; i < num; i++)
					{
						userid = players[ i ]
						
						iColors[0] = (get_user_health(userid) > iAmount) ? 255:0;
						iColors[1] = (get_user_health(userid) <= iAmount) ? 255:0;
						UTIL_ScreenFade(userid, iColors, -1.0, 3.0, 200, FFADE_MODULATE)
						set_user_health(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_HEALING_TEAM", sName, team, iAmount)
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						userid = id
						iAmount = str_to_num(sOutput[2]);
					}
					else iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
						return 0
					}
				}
			}
			
			new iColors[3]; iColors[0] = (get_user_health(userid) > iAmount) ? 255:0;
			iColors[1] = (get_user_health(userid) <= iAmount) ? 255:0;
			UTIL_ScreenFade(userid, iColors, _, 3.0, 200, FFADE_MODULATE)
			set_user_health(userid, iAmount)
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_HEALING_PLAYER", sName, sOutput[2], iAmount)
			return 1
		}
		if(equali(sOutput[1], "armour") || equali(sOutput[1], "armor"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = str_to_num(sOutput[3]);
					if(!iAmount)
					{
						cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
						return 0
					}
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "all players")
						}
						default: {
							cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
							return 0
						}
					}
					
					for(new i = 0; i < num; i++)
					{
						userid = players[ i ]
						
						set_user_armor(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_AROMR_TEAM", sName, team, iAmount)
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						userid = id
						iAmount = str_to_num(sOutput[2]);
					}
					else iAmount = str_to_num(sOutput[3]);
					
					if(!iAmount)
					{
						cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
						return 0;
					}
				}
			}
			
			set_user_armor(userid, iAmount)
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_ARMOR_PLAYER", sName, sOutput[2], iAmount)
			return 1;
		}
		if(equali(sOutput[1], "noclip"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = clamp(str_to_num(sOutput[3]), 0, 1)
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "all players")
						}
						default: {
							cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
							return 0
						}
					}
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_noclip(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_NOCLIP_TEAM", sName, team, iAmount ? "On":"Off")
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						userid = id
					}
				}
			}
			
			set_user_noclip(userid, get_user_noclip(userid) ? 0:1)
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_NOCLIP_PLAYER", sName, sOutput[2], get_user_noclip(userid) ? "On":"Off")
			return 1
		}
		if(equali(sOutput[1], "godmode"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					iAmount = clamp(str_to_num(sOutput[3]), 0, 1)
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "all players")
						}
						default: {
							cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
							return 0
						}
					}
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_godmode(userid, iAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GODMODE_TEAM", sName, team, iAmount ? "On":"Off")
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						userid = id
					}
				}
			}
			
			set_user_godmode(userid, get_user_godmode(userid) ? 0:1)
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GODMODE_PLAYER", sName, sOutput[2], get_user_godmode(userid) ? "On":"Off")
			return 1
		}
		if(equali(sOutput[1], "gravity"))
		{
			switch( sOutput[2][0] )
			{
				case '@':
				{
					if(!strlen(sOutput[3]))
					{
						cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
						return 0
					}
					
					iAmount = str_to_num(sOutput[3])
					new players[32], num, team[32]
					
					switch( sOutput[2][1] )
					{
						case 'C' , 'c': {
							get_players(players, num, "ahe", "CT")
							formatex(team, charsmax(team), "Counter-terrorist")
						}
						case 'T' , 't': {
							get_players(players, num, "ahe", "TERRORIST")
							formatex(team, charsmax(team), "terrorist")
						}
						case 'S' , 's': {
							get_players(players, num, "ahe", "SPECTATOR")
							formatex(team, charsmax(team), "spectators")
						}
						case 'A' , 'a': {
							get_players(players, num, "ah")
							formatex(team, charsmax(team), "all players")
						}
						default: {
							cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
							return 0
						}
					}
					
					new Float:fAmount = iAmount/800.0
					
					for(new i = 0; i < num ;i++)
					{
						userid = players[ i ]
						
						set_user_gravity(userid, fAmount)
					}
					
					get_user_name(id, sName, charsmax(sName))
					cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GRAVITY_TEAM", sName, team, iAmount)
					return 1
				}
				default:
				{
					userid = cmd_target(id, sOutput[2], CMDTARGET_ALLOW_SELF)
					
					if(!userid)
					{
						userid = id
						iAmount = str_to_num(sOutput[2])
					}
					else iAmount = str_to_num(sOutput[3]);
				}
			}
			
			set_user_gravity(userid, (iAmount / 800.0))
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			get_user_name(id, sName, charsmax(sName))
			cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_GRAVITY_PLAYER", sName, sOutput[2], iAmount)
			return 1
		}
		if(equali(sOutput[1], "cell", 4) || equali(sOutput[1], "button", 6))
		{
			new target, body;
			get_user_aiming(id, target, body, 500)
			
			if(pev_valid(target))
			{
				new sClassname[24];
				pev(target, pev_classname, sClassname, charsmax(sClassname))
				
				if(!equal(sClassname, "func_button") && !equal(sClassname, "button_target") && !equal(sClassname, "func_door"))
				{
					cprint_chat(id, _, "%L", id, "INVAILD_CELLS_BUTTON")
					return 1;
				}
				
				new szMapname[32];
				get_mapname(szMapname, charsmax(szMapname));
				save_map_cells_button(target)
				cprint_chat(id, _, "%L", id, "MAP_CELLS_BUTTON_SAVED", target, szMapname)
			}
			else
			{
				cprint_chat(id, _, "%L", id, "COMMAND_TARGET_NOT_FOUND")
			}
			
			return 1;
		}
		
		cprint_chat(id, _, "%L", id, "COMMANDS_USAGE")
		return 1;
	}
	if(equali(sOutput[0], "/revive"))
	{
		if(!cmd_access(id, level, cid, 1))
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
			return 0;
		}
		
		switch( sOutput[1][0] )
		{
			case '@':
			{
				new players[32], num, team[32], sFlags[5];
				
				switch( sOutput[1][2] )
				{
					case 'A', 'a': {
						add(sFlags, charsmax(sFlags), "ah")
						formatex(team, charsmax(team), "(Alive) ")
					}
					case 'D', 'd': {
						add(sFlags, charsmax(sFlags), "bh")
						formatex(team, charsmax(team), "(Dead) ")
					}
					default: add(sFlags, charsmax(sFlags), "h")
				}
				switch( sOutput[1][1] )
				{
					case 'C' , 'c': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "CT")
						format(team, charsmax(team), "%sCounter-terrorist", team)
					}
					case 'T' , 't': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "TERRORIST")
						format(team, charsmax(team), "%sTerrorist", team)
					}
					case 'S' , 's': {
						add(sFlags, charsmax(sFlags), "e")
						get_players(players, num, sFlags, "SPECTATOR")
						format(team, charsmax(team), "%sSpectators", team)
					}
					case 'A' , 'a': {
						get_players(players, num, sFlags)
						format(team, charsmax(team), "all %sPlayers", team)
					}
					default: {
						cprint_chat(id, 'n', "%L", id, "COMMAND_TARGET_NOT_FOUND")
						return 0
					}
				}
				
				for(new i = 0; i < num ;i++)
				{
					userid = players[ i ]
					if(cs_get_user_team(userid) == CS_TEAM_SPECTATOR) continue
					ExecuteHamB(Ham_CS_RoundRespawn, userid)
				}
				
				get_user_name(id, sName, charsmax(sName))
				cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_REVIVE_TEAM", sName, team)
				return 1
			}
			default:
			{
				userid = cmd_target(id, sOutput[1], CMDTARGET_ALLOW_SELF)
				
				if(!userid)
				{
					userid = id;
				}
			}
		}
		if(cs_get_user_team(userid) == CS_TEAM_SPECTATOR){
			cprint_chat(id, 'n', "Spectators can't be alive!")
			return 0
		}
		ExecuteHamB(Ham_CS_RoundRespawn, userid)
		get_user_name(userid, sOutput[1], charsmax(sOutput[]))
		get_user_name(id, sName, charsmax(sName))
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_REVIVE_PLAYER", sOutput[1], sName)
		return 1
	}
	else if(equali(sOutput[0], "/donate"))
	{
		userid = cmd_target(id, sOutput[1], CMDTARGET_NO_BOTS)
		iAmount = str_to_num(sOutput[2])
		
		if(userid == id)
		{
			cprint_chat(id, 'n', "%L", id, "DONATION_SELF")
			return 0
		}
		if(!strlen(sOutput[2]) || !iAmount || contain(sOutput[2], "-") != -1)
		{
			cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
			return 0
		}
		if(user_cash[id] < iAmount)
		{
			cprint_chat(id, 'n', "%L", id, "DONATION_DONT_HAVE")
			return 0
		}
		if(!is_user_registered(id)){
			cprint_chat(id, 'n', "[JailBreak] Only registered users can use this command! Register your nick @ ugc-gaming.net")
			return 0
		}
		get_user_name(userid, sOutput[1], charsmax(sOutput[]))
		if(userid && !is_user_registered(userid)){
			cprint_chat(id, 'n', "[JailBreak] Only registered users can receive cash. '%s' doesn't have nick registered!", sOutput[1])
			return 0
		}
		get_user_name(id, sName, charsmax(sName))
		jb_set_user_cash(userid, iAmount+jb_get_user_cash(userid))
		jb_set_user_cash(id, jb_get_user_cash(id)-iAmount)
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "DONATION_PROGRESS", sName, sOutput[1], iAmount)
		return 1
	}
	if(equali(sOutput[0], "/shop") || equali(sOutput[0], "!shop"))
	{
		shop_menu(id);return 1;
	}
	if(equali(sOutput[0], "/cash"))
	{
		iAmount = str_to_num(sOutput[3])
		userid = cmd_target(id, sOutput[2], CMDTARGET_NO_BOTS)
		
		if(!userid && read_argc() <= 2)
		{
			userid = cmd_target(id, sOutput[1], CMDTARGET_NO_BOTS)
			
			if(userid && read_argc() <= 2)
			{
				get_user_name(userid, sOutput[2], charsmax(sOutput[]))
				cprint_chat(id, 'n', "%L", id, "PLAYER_CHECK_PLAYER_CASH", sOutput[2], user_cash[userid])
				return 1
			}
			
			cprint_chat(id, 'n',"%L", id, "PLAYER_CHECK_CASH", user_cash[id])
			return 1
		}
		if(equali(sOutput[1], "give"))
		{
			if(!cmd_access(id, level, cid, 1) || !access(id, ADMIN_SUPER))
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
				return 0
			}
			if(!strlen(sOutput[3]) || !iAmount)
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
				return 0
			}
			
			get_user_name(id, sName, charsmax(sName))
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			jb_set_user_cash(userid, iAmount+jb_get_user_cash(userid))
			cprint_chat(id, 'n', "%L", id, "ADMIN_GIVE_CASH_PLAYER", sName, sOutput[2], iAmount)
			if(userid != id)
				cprint_chat(userid, 'n', "%L", userid, "ADMIN_GIVE_CASH_PLAYER", sName, sOutput[2], iAmount)
			return 1;
		}
		if(equali(sOutput[1], "take"))
		{
			if(!cmd_access(id, level, cid, 1) || !access(id, ADMIN_SUPER))
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
				return 0
			}
			if(!strlen(sOutput[3]) || !iAmount)
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
				return 0
			}
			
			get_user_name(id, sName, charsmax(sName))
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			jb_set_user_cash(userid, jb_get_user_cash(userid)-iAmount)
			
			cprint_chat(id, 'n', "%L", id, "ADMIN_TOOK_CASH_PLAYER", sName, sOutput[2], iAmount)
			if(userid != id)
				cprint_chat(userid, 'n', "%L", userid, "ADMIN_TOOK_CASH_PLAYER", sName, sOutput[2], iAmount)
			return 1;
		}
		if(equali(sOutput[1], "set"))
		{
			if(!cmd_access(id, level, cid, 1) || !access(id, ADMIN_SUPER))
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_NOACCESS")
				return 0
			}
			if(!strlen(sOutput[3]) || !iAmount)
			{
				cprint_chat(id, 'n', "%L", id, "COMMAND_VALUE_ISMISSING")
				return 0
			}
			
			get_user_name(id, sName, charsmax(sName))
			get_user_name(userid, sOutput[2], charsmax(sOutput[]))
			jb_set_user_cash(userid, iAmount)
			cprint_chat(id, 'n', "%L", id, "ADMIN_SET_CASH_PLAYER", sName, sOutput[2], iAmount)
			if(userid != id)
				cprint_chat(userid, 'n', "%L", userid, "ADMIN_SET_CASH_PLAYER", sName, sOutput[2], iAmount)
			return 1;
		}
		
		return 1;
	}
	
	return 0;
}

stock str_explode(const string[], delimiter, output[][], output_size, output_len)
{
	new i, pos, len = strlen(string)
	
	do
	{
		pos += (copyc(output[i++], output_len, string[pos], delimiter) + 1)
	}
	while(pos < len && i < output_size)
	
	return i
}

bool:Check_shop_available(id, bool:bMsg=false)
{
	if(g_lr_inprogress != -1)
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS")
		return false;
	}
	if(!check_flag(IsUserAlive,id))
	{
		if(bMsg) cprint_chat(id, 'n', "%L", id, "MENU_NOT_ALIVE")
		return false;
	}
	
	return true;
}

public shop_menu(id)
{
	if(!g_shop_items)
	{
		log_amx("There is no items in the API jailbreak shop.")
		return
	}
	if(!Check_shop_available(id, true)) return;
	
	new sText[128], JBSmenu, sItemname[32], iItemcost, sData[2], uteam, iteam_team, sIteminfo[32]
	
	uteam = get_user_team(id);
	
	formatex(sText, charsmax(sText), "\r[ \yJail-Break \r] \wShop \rmenu^nCash: $%d", user_cash[id])
	JBSmenu = menu_create(sText, "shop_menu_handle")
	
	new bitsum_day = (1<<(g_day_inprogress + 1));
	
	for(new i, iItemaccess; i < g_shop_items; i++)
	{
		if(!(bitsum_day & ArrayGetCell(g_shop_items_bitsumdays, i)))
		{
			continue;
		}
		
		ExecuteForward(fw_shop_item_select_pre, g_fw_return, id, i)
		
		if(g_fw_return == JB_MENU_ITEM_DONT_SHOW)
		{
			continue;
		}
		
		iteam_team = ArrayGetCell(g_shop_items_team, i)
		
		if(iteam_team != uteam && iteam_team != TEAM_ANY)
		{
			continue;
		}
		
		ArrayGetString(g_shop_items_name, i, sItemname, charsmax(sItemname))
		ArrayGetString(g_shop_items_info, i, sIteminfo, charsmax(sIteminfo))
		iItemcost = ArrayGetCell(g_shop_items_cost, i)
		iItemaccess = ArrayGetCell(g_shop_items_access, i);
		
		sData[0] = i
		sData[1] = '^0'
		
		if(g_fw_return == JB_MENU_ITEM_UNAVAILABLE)
		{
			formatex(sText, charsmax(sText), "\d%s  %s [Price: $%d]", sItemname, sIteminfo, iItemcost)
			iItemaccess = (1<<26);
		}
		else
		{
			user_cash[id] < iItemcost ? formatex(sText, charsmax(sText), "\d%s  %s \r[Price: $%d]", sItemname, sIteminfo, iItemcost):formatex(sText, charsmax(sText), "\r%s  \y%s \w[\yPrice: \r$%d\w]", sItemname, sIteminfo, iItemcost)
		}
		if(!equali(sItemname, "Bazooka"))
			menu_additem(JBSmenu, sText, sData, iItemaccess);
	}
	
	menu_setprop(JBSmenu, MPROP_PERPAGE, 5)
	menu_setprop(JBSmenu, MPROP_EXIT, MEXIT_ALL)
	
	menu_display(id, JBSmenu)
}

public shop_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || !Check_shop_available(id, false))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new paccess, sData[2], sName[64], iIndex, sItemname[32], iItemcost
	menu_item_getinfo(menu, item, paccess, sData, charsmax(sData), sName, charsmax(sName), iIndex)
	
	menu_destroy(menu)
	iIndex = sData[0];
	
	ArrayGetString(g_shop_items_name, iIndex, sItemname, charsmax(sItemname))
	iItemcost = ArrayGetCell(g_shop_items_cost, iIndex)
	
	ExecuteForward(fw_shop_item_select_post, g_fw_return, id, iIndex)
	
	new szPlayerName[32], sAuthid[32], sTeam[16];
	get_user_name(id, szPlayerName, charsmax(szPlayerName))
	get_user_authid(id, sAuthid, charsmax(sAuthid))
	get_user_team(id, sTeam, charsmax(sTeam))
	
	if(g_fw_return == JB_MENU_ITEM_UNAVAILABLE)
	{
		logevent_message("^"%s<%d><%s><%s>^" ^"Couldn't buy^" ^"%s^" ^"Item is not available^"", szPlayerName, get_user_userid(id), sAuthid, sTeam, sItemname)
		cprint_chat(id, 'n', "%L", "SHOP_ITEM_NOT_AVAILABLE")
		return PLUGIN_HANDLED;
	}
	
	if(g_fw_return == JB_SHOP_ITEM_IGNORE_COST)
	{
		logevent_message("^"%s<%d><%s><%s>^" ^"Got^" ^"%s^" ^"For free^"", szPlayerName, get_user_userid(id), sAuthid, sTeam, sItemname)
		
		ExecuteForward(fw_shop_item_bought, g_fw_return, id, iIndex)
		cprint_chat(id, 'n', "%L", id, "SHOP_FREE_ITEM", sItemname)
		return PLUGIN_HANDLED;
	}
	
	if(user_cash[id] < iItemcost)
	{
		logevent_message("^"%s<%d><%s><%s>^" ^"Couldn't Buy^" ^"%s^" ^"No enough cash^"", szPlayerName, get_user_userid(id), sAuthid, sTeam, sItemname)
		cprint_chat(id, 'n', "%L", id, "SHOP_NO_ENOUGH_CASH")
		return PLUGIN_HANDLED;
	}
	
	ExecuteForward(fw_shop_item_bought, g_fw_return, id, iIndex)
	cprint_chat(id, 'n', "%L", id, "SHOP_ITEM_BOUGHT", sItemname, iItemcost)
	jb_set_user_cash(id, jb_get_user_cash(id)-iItemcost)
	
	logevent_message("^"%s<%d><%s><%s>^" ^"Bought^" ^"%s^"", szPlayerName, get_user_userid(id), sAuthid, sTeam, sItemname)
	
	return PLUGIN_HANDLED;
}

// native register_jailbreak_shopitem(const name[], const info[], cost, team, const access=0, const bitsum_days=0)
public _register_jailbreak_shopitem(plugin, argc)
{
	if(argc != 6) return -2;
	
	new item_name[36], item_info[32], item_cost, item_team, item_bitsum_days
	get_string(1, item_name, charsmax(item_name));
	get_string(2, item_info, charsmax(item_info));
	item_cost = get_param(3);
	item_team = get_param(4);
	new item_access = get_param(5);
	item_bitsum_days = get_param(6);
	
	if(strlen(item_name) < 3)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item name is too short!", plugin, 1)
		return -1;
	}
	if(!(TEAM_ANY <= item_team <= TEAM_SPECTATOR))
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item team is not defined!", plugin, 4)
		return -1;
	}
	if(get_itemid_inarray_bystring(item_name, g_shop_items_name) > -1)
	{
		log_error(AMX_ERR_NATIVE, "Native Error Plugin #%d , Parameter @%d , item with this name is already registered!", plugin, 1)
		return -1;
	}
	
	new szCost[32], szTeam[4],  szDay[4] = "YES";
	//get_file_keyvalue(jb_shop_ini_file, item_name, "NAME", item_name, charsmax(item_name));
	get_file_keyvalue(jb_shop_ini_file, item_name, "INFO", item_info, charsmax(item_info));
	
	num_to_str(item_cost, szCost, charsmax(szCost))
	get_file_keyvalue(jb_shop_ini_file, item_name, "COST", szCost, charsmax(szCost));
	
	num_to_str(item_team, szTeam, charsmax(szTeam))
	get_file_keyvalue(jb_shop_ini_file, item_name, "TEAM", szTeam, charsmax(szTeam));
	
	get_file_keyvalue(jb_shop_ini_file, item_name, "DAY_NONE", szDay, charsmax(szDay));
	if(equali(szDay, "YES")) item_bitsum_days |= (1<<0);
	
	ArrayPushString(g_shop_items_name, item_name)
	ArrayPushString(g_shop_items_info, item_info)
	ArrayPushCell(g_shop_items_cost, str_to_num(szCost))
	ArrayPushCell(g_shop_items_team, str_to_num(szTeam))
	ArrayPushCell(g_shop_items_bitsumdays, item_bitsum_days)
	ArrayPushCell(g_shop_items_access, item_access)
	
	g_shop_items ++
	return g_shop_items-1
}

// jb_get_shop_items_registered()
public _get_shop_items_registered(plugin, argc)
{
	return g_shop_items;
}

// jb_update_shop_item(itemid, const newname[], const newinfo[], const newcost, const newaccess, const newteam[], const newbitsumdays)
public _update_shop_item(plugin, argc)
{
	new itemid = get_param(1);
	
	if(!(0 <= itemid < g_shop_items))
	{
		log_error(AMX_ERR_NATIVE, "Native Error itemid is not valid!")
		return -1;
	}
	
	new name[32], info[32];
	get_string(2, name, charsmax(name))
	get_string(3, info, charsmax(info))
	new cost = get_param(4);
	new paccess = get_param(5);
	new team = get_param(6);
	new item_bitsdays = get_param(7);
	
	if(strlen(name) > 0)
		ArraySetString(g_shop_items_name, itemid, name);
	if(strlen(info) > 0)
		ArraySetString(g_shop_items_info, itemid, info);
	if(cost > -1)
		ArraySetCell(g_shop_items_cost, itemid, cost);
	if(paccess > -1)
		ArraySetCell(g_shop_items_access, itemid, paccess);
	if(TEAM_SPECTATOR >= team >= TEAM_ANY)
		ArraySetCell(g_shop_items_team, itemid, team);
	if(item_bitsdays > -1)
		ArraySetCell(g_shop_items_bitsumdays, itemid, item_bitsdays);
	
	return 0;
}

// native jb_set_user_cash(index, amount)
public _set_user_cash(plugin, argc) jb_set_user_cash(get_param(1), get_param(2))
jb_set_user_cash(id, amount)
{
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not (valid/connected)!")
		return -1
	}
	
	user_cash[id] = amount;
	
	message_begin(MSG_ONE, g_msgMoney, _, id);
	write_long(amount);
	write_byte(1);
	message_end();
	
	return 1
}

// native jb_get_user_cash(index)

public _get_user_cash(plugin, argc) return jb_get_user_cash(get_param(1));
jb_get_user_cash(id)
{
	if(!(1 <= id <= g_iMaxplayers))
	{
		log_error(AMX_ERR_NATIVE, "Native Error user id is not valid!")
		return -1
	}
	
	return user_cash[id];
}

public _end_theday()
{
	if(g_day_inprogress != -1)
	{
		if(g_day_inprogress > -1)
		{
			new sDayname[64];
			ArrayGetString(g_days_itemname, g_day_inprogress, sDayname, charsmax(sDayname))
			logevent_message("^"%s^" Day has ended!", sDayname)
		}
		
		ExecuteForward(fw_day_ended, g_fw_return, g_day_inprogress)
		g_day_inprogress = -1;
		g_day_length = 0.0;
		
		for(new i = 1; i <= g_iMaxplayers; i++) g_user_wpns_blocked[i] = 0;
	}
}

bool:Check_day_available(id, bool:msg=false)
{
	if(g_day_inprogress > -1)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "DAY_INPROGRESS")
		return false;
	}
	if(g_day_inprogress == -2)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "VOTEDAY_INPROGRESS")
		return false;
	}
	if(g_lr_inprogress != -1)
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "LR_INPROGRESS")
		return false;
	}
	if(get_prisonersnum(FLAG_ALIVE_ONLY) < 2 || !get_guardsnum(FLAG_ALIVE_ONLY))
	{
		if(msg) cprint_chat(id, 'n', "%L", id, "DAY_REQUIRES")
		return false;
	}
	return true;
}

public Show_votedays_menu()
{
	if(!g_days_items)
	{
		return;
	}
	
	new gloop = MAX_VOTEDAYS;
	
	if(gloop > g_days_items)
	{
		gloop = g_days_items
	}
	
	new Array:VDays = ArrayCreate(1, 1)
	
	for(new i = 0; i < g_days_items; i++)
	{
		ArrayPushCell(VDays, i)
	}
	
	new VDChosen;
	
	for(new i = 0; i < gloop; i++)
	{
		VDChosen = random((ArraySize(VDays)))
		g_votedays_chosen[i] = ArrayGetCell(VDays, VDChosen)
		ArrayDeleteItem(VDays, VDChosen)
		g_votedays_vote[i] = 0;
	}
	
	ArrayDestroy(VDays)
	
	new players[32], pnum, player
	get_players(players, pnum, "ch")
	
	g_votedays_voted = 0;
	
	for(new i = 0; i < pnum; i++)
	{
		player = players[i]
		remove_flag(g_votedays_voted,player);
		set_flag(g_has_avotedaymenu,player);
		set_user_godmode(player, 1)
		votedays_menu(player, 0)
	}
	
	logevent_message("Voteday has begin!")
	g_day_inprogress = -2;
	g_votedays_timer = get_pcvar_num(g_iCvar_identity[CVAR_VDAY_TIMER])
	remove_task(TASK_VOTEDAY_TIMER)
	set_task(1.0, "votedays_menu_timer", TASK_VOTEDAY_TIMER, _, _, "b")
}

public votedays_menu_timer(Taskid)
{
	if(g_votedays_timer >= 0)
	{
		new sWord[16]
		num_to_word(g_votedays_timer, sWord, charsmax(sWord))
		client_cmd(0, "spk ^"%s^"", sWord)
		
		new players[32], pnum, player, iPage, menu, newmenu
		get_players(players, pnum, "ch")
		
		for(new i = 0; i < pnum; i++)
		{
			player = players[i];
			
			if(check_flag(g_has_avotedaymenu,player))
			{
				if(player_menu_info(player, menu, newmenu, iPage) > 0) menu_cancel(player);
				votedays_menu(player, iPage)
			}
		}
		
		g_votedays_timer--;
	}
	else
	{
		remove_task(Taskid)
		
		new votes_bigger, votes, bigger, gloop = MAX_VOTEDAYS;
		
		if(gloop > g_days_items)
		{
			gloop = g_days_items;
		}
		
		for(new i = 0; i < gloop; i++)
		{
			votes = g_votedays_vote[i]
			votes_bigger = g_votedays_vote[bigger]
			
			if(votes_bigger < votes)
			{
				bigger = i
			}
		}
		
		new chosen_day = g_votedays_chosen[bigger]
		new sDayname[32];
		ArrayGetString(g_days_itemname, chosen_day, sDayname, charsmax(sDayname))
		
		new players[32], pnum;
		get_players(players, pnum, "ah")
		
		for(new i, menu, newmenu, iPage; i < pnum; i++)
		{
			bigger = players[i];
			if(check_flag(g_has_avotedaymenu,bigger))
			{
				if(player_menu_info(bigger, menu, newmenu, iPage)) {
					menu_cancel(bigger);
					show_menu(bigger, 0, "^n ", -1);
				}
			}
			
			set_entity_flags(bigger, FL_FROZEN, 0)
		}
		
		g_votedays_timer = clamp(get_pcvar_num(g_iCvar_identity[CVAR_VDAY_TIMER2]),-1,60);
		cprint_chat(0, _, "%L", LANG_PLAYER, "VOTEDAY_CHOSEN_DAY", sDayname, sDayname)
		set_task(1.0, "chosen_voteday", chosen_day+TASK_VOTEDAY_TIMER, sDayname, charsmax(sDayname), g_votedays_timer<=-1 ? "":"b");
		logevent_message("Voteday has finished!")
	}
}

public chosen_voteday(const sParam[], taskid)
{
	if(g_day_inprogress != -2)
	{
		remove_task(taskid);
		return;
	}
	
	if(g_votedays_timer >= 0)
	{
		if(g_votedays_timer <= 5)
		{ 
			static sWord[16];
			num_to_word(g_votedays_timer, sWord, charsmax(sWord))
			client_cmd(0, "spk ^"%s^"", sWord)
		}
		
		client_print(0, print_center, "%L", LANG_PLAYER, "CENTER_VOTEDAY_STARTS", sParam, g_votedays_timer)
		g_votedays_timer--;
		return;
	
	}
	
	remove_task(taskid);
	
	new plyrs[32], pnum;
	get_players(plyrs, pnum, "ah")
	
	for(new i = 0; i < pnum; i++) set_user_godmode(plyrs[i], 0);
	
	new iDayid = taskid - TASK_VOTEDAY_TIMER;
	
	g_day_inprogress = iDayid;
	ExecuteForward(fw_day_start, g_fw_return, iDayid)
	
	new sDayname[32];
	ArrayGetString(g_days_itemname, iDayid, sDayname, charsmax(sDayname))
	
	logevent_message("^"%s^" Day has started!", sDayname)
	
	new Float:fLength = ArrayGetCell(g_days_itemlength, iDayid);
	
	if(fLength)
	{
		g_day_length = fLength;
		remove_task(TASK_DAY_LENGTH+iDayid)
		set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b")
	}
}

public votedays_menu(id, iPage)
{
	if(g_votedays_timer == -1)
	{
		return
	}
	
	new sText[98]
	
	formatex(sText, charsmax(sText), "\r[ \yJailbreak \r] %L", id, "VOTEDAY_MENU", g_votedays_timer)
	if(!check_flag(g_votedays_voted,id)) format(sText, charsmax(sText), "%s^n%L", sText, id, "VOTEDAY_MENU_CHOOSEDAY")
	new iMenu = menu_create(sText, "votedays_menu_handle")
	
	new sItem[32], iAccess, sData[4]
	
	new gloop = MAX_VOTEDAYS, iDayid;
	
	if(gloop > g_days_items)
	{
		gloop = g_days_items
	}
	
	new players[32], pnum;
	get_players(players, pnum, "ch")
	
	new voters = 1;
	for(new x; x < pnum; x++) if(check_flag(g_votedays_voted,players[x])) voters++;
	
	for(new i, vote_percent; i < gloop; i++)
	{
		iDayid = g_votedays_chosen[i]
		vote_percent = floatround(g_votedays_vote[i] * 100.0 / voters);
		
		ArrayGetString(g_days_itemname, iDayid, sItem, charsmax(sItem))
		iAccess = ArrayGetCell(g_days_itemaccess, iDayid)
		
		ExecuteForward(fw_day_preselected, g_fw_return, id, iDayid, iAccess)
		
		switch( g_fw_return )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				formatex(sText, charsmax(sText), "\d%s       (~ %d%% ~)", sItem, vote_percent);
				iAccess = (1<<26);
			}
			default: formatex(sText, charsmax(sText), "\r%s       \y(~ %d%% ~)", sItem, vote_percent);
		}
		
		num_to_str(iDayid, sData, charsmax(sData))
		menu_additem(iMenu, sText, sData, iAccess, -1)
	}
	
	menu_display(id, iMenu, iPage)
	set_flag(g_has_avotedaymenu,id)
}

public votedays_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || !task_exists(TASK_VOTEDAY_TIMER))
	{
		remove_flag(g_has_avotedaymenu,id)
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sDayname[32], sData[4]
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sDayname, charsmax(sDayname), iCallback)
	
	new oldmenu, newmenu, iPage
	player_menu_info(id, oldmenu, newmenu, iPage);
	
	menu_destroy(menu);
	
	if(contain(sDayname, "\d") != -1)
	{
		votedays_menu(id, iPage)
		return PLUGIN_HANDLED;
	}
	
	new dayid = str_to_num(sData)
	
	ExecuteForward(fw_day_postselected, g_fw_return, id, dayid, iAccess)
	
	if(g_fw_return == JB_MENU_ITEM_UNAVAILABLE)
	{
		votedays_menu(id, iPage)
		return PLUGIN_HANDLED;
	}
	
	if(!check_flag(g_votedays_voted,id))
	{
		set_flag(g_votedays_voted,id);
		new admin_vote = get_pcvar_num(g_iCvar_identity[CVAR_VDAY_ADMIN_EXVOTE])
		new advote = (get_user_flags(id) & ADMIN_VOTE) ? true:false
		g_votedays_vote[item] += advote ? (++admin_vote):1
		
		new sName[32], sAuthid[32], sTeam[16];
		get_user_name(id, sName, charsmax(sName))
		get_user_authid(id, sAuthid, charsmax(sAuthid))
		get_user_team(id, sTeam, charsmax(sTeam))
		logevent_message("^"%s<%d><%s><%s>^" has voted for ^"%s^"", sName, get_user_userid(id), sAuthid, sTeam, sDayname)
		
		ArrayGetString(g_days_itemname, dayid, sDayname, charsmax(sDayname))
		cprint_chat(0, 'n', "%L", LANG_PLAYER, "VOTEDAY_PLAYER_VOTED", sName, sDayname)
		
		new players[32], pnum, player
		get_players(players, pnum, "ch")
		
		for(new i = 0; i < pnum; i++)
		{
			player = players[i]
			
			if(check_flag(g_has_avotedaymenu,player))
			{
				if(player_menu_info(player, oldmenu, newmenu, iPage) > 0) menu_cancel(player);
				votedays_menu(player, iPage)
			}
		}
	}
	else
	{
		client_print(id, print_center, "%L", id, "CENTER_CANT_VOTE_TWICE")
		votedays_menu(id, iPage)
	}
	
	return PLUGIN_HANDLED;
}

public days_menu(id)
{
	if(!Check_day_available(id, true))
	{
		return;
	}
	if(!(get_user_flags(id) & ADMIN_IMMUNITY))
	{
		cprint_chat(id, 'n', "%L", id, "MENU_NOACCESS")
		return;
	}
	
	new iMenu = menu_create("\r[ \yJailbreak \r]  \wDay's", "days_menu_handle")
	
	new sItem[64], iAccess, sData[4]
	
	for(new i; i < g_days_items; i++)
	{
		iAccess = ArrayGetCell(g_days_itemaccess, i)
		
		ExecuteForward(fw_day_preselected, g_fw_return, id, i, iAccess)
		
		switch( g_fw_return )
		{
			case JB_MENU_ITEM_DONT_SHOW: continue;
			case JB_MENU_ITEM_UNAVAILABLE:
			{
				ArrayGetString(g_days_itemname, i, sItem, charsmax(sItem))
				format(sItem, charsmax(sItem), "\d%s", sItem);
				iAccess = (1<<26);
			}
			default: ArrayGetString(g_days_itemname, i, sItem, charsmax(sItem))
		}
		
		num_to_str(i, sData, charsmax(sData));
		menu_additem(iMenu, sItem, sData, iAccess);
	}
	
	menu_display(id, iMenu)
}

public days_menu_handle(id, menu, item)
{
	if(item == MENU_EXIT || !Check_day_available(id, true))
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED;
	}
	
	new sDayname[32], sData[4]
	new iAccess, iCallback
	menu_item_getinfo(menu, item, iAccess, sData, charsmax(sData), sDayname, charsmax(sDayname), iCallback)
	
	menu_destroy(menu);
	
	if(contain(sDayname, "\d") != -1)
	{
		days_menu(id)
		return PLUGIN_HANDLED;
	}
	
	new dayid = str_to_num(sData)
	
	ExecuteForward(fw_day_postselected, g_fw_return, id, dayid, iAccess)
	
	if(g_fw_return == JB_MENU_ITEM_UNAVAILABLE)
	{
		days_menu(id)
		return PLUGIN_HANDLED;
	}
	
	g_day_inprogress = dayid
	ExecuteForward(fw_day_start, g_fw_return, dayid)
	
	new Float:fLength = ArrayGetCell(g_days_itemlength, dayid)
	
	if(fLength > 0.0)
	{
		g_day_length = fLength
		remove_task(TASK_DAY_LENGTH+dayid)
		set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b")
	}
	
	new sAdminname[32]
	get_user_name(id, sAdminname, charsmax(sAdminname))
	cprint_chat(0, 'n', "%L", LANG_PLAYER, "ADMIN_START_ASPECIFIED_DAY", sAdminname, sDayname)
	
	new sAuthid[32], sTeam[16];
	get_user_authid(id, sAuthid, charsmax(sAuthid))
	get_user_team(id, sTeam, charsmax(sTeam))
	logevent_message("^"%s<%d><%s><%s>^" Admin has started a ^"%s^"", sAdminname, get_user_userid(id), sAuthid, sTeam, sDayname)
	
	
	return PLUGIN_HANDLED;
}

public task_day_length(taskid)
{
	if(g_day_length <= 0.0)
	{
		remove_task(taskid);
		_end_theday();
		
		if(!get_guardsnum(FLAG_ALIVE_ONLY) || !get_prisonersnum(FLAG_ALIVE_ONLY))
		{
			TerminateRound(RoundEndType_TeamExtermination);
		}
		
		return;
	}
	
	g_day_length-= 1.0;
}

// native jb_get_days_registered()
public _get_days_registered(plugin, argc)
{
	return g_days_items
}

// native jb_get_dayid_byname(const dayname[])
public _get_dayid_byname(plugin, argc)
{
	new sDayname[32]
	get_string(1, sDayname, charsmax(sDayname))
	
	return (get_itemid_inarray_bystring(sDayname, g_days_itemname));
}

// native jb_get_day_name(iDayid, sName[], iLen)
public _get_day_name(plugin, argc)
{
	new iDayid = get_param(1)
	
	if(0 > iDayid || g_days_items <= iDayid)
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id #%d", iDayid)
		return 0;
	}
	
	new sDayname[32]
	ArrayGetString(g_days_itemname, iDayid, sDayname, charsmax(sDayname))
	set_string(2, sDayname, get_param(3))
	
	return 1;
}

// native get the day length time
public Float:_get_day_length(plugin, argc)
{
	return g_day_length
}

// native set the day length time
public _set_day_length(plugin, argc)
{
	new dayid = get_param(1);
	
	if(!(0 <= dayid < g_days_items))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id")
		return;
	}
	
	ArraySetCell(g_days_itemlength, dayid, get_param_f(2));
}

// native jb_start_theday(iDayid)
public _start_theday(plugin, argc)
{
	new dayid = get_param(1);
	if(!(0 <= dayid < g_days_items))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid Day id")
		return;
	}
	
	if(g_day_inprogress > -1)
	{
		log_error(AMX_ERR_NATIVE, "Error: There is already a day started!")
		return;
	}
	
	g_day_inprogress = dayid
	ExecuteForward(fw_day_start, g_fw_return, dayid)
	
	new sDayname[32];
	ArrayGetString(g_days_itemname, dayid, sDayname, charsmax(sDayname))
	
	logevent_message("^"%s^" Day has started!", sDayname)
	
	new Float:fLength = ArrayGetCell(g_days_itemlength, dayid)
	
	if(fLength)
	{
		g_day_length = fLength;
		remove_task(TASK_DAY_LENGTH)
		set_task(1.0, "task_day_length", TASK_DAY_LENGTH, _, _, "b")
	}
}

// native register_jailbreak_day(const name[], iAccess, Float:fDay_Length=0.0, const Day_End)
public _register_jailbreak_day(plugin, argc)
{
	if(argc != 4)
	{
		log_error(AMX_ERR_NATIVE, "Error: Arguments doesn't match!")
		return -2;
	}
	
	new sItem[32], iAccess, Float:fLength;
	get_string(1, sItem, charsmax(sItem));
	iAccess = get_param(2);
	fLength = get_param_f(3);
	
	if(strlen(sItem) < 3)
	{
		formatex(sItem, charsmax(sItem), "Error : Invalid day name (PLUGIN : %d | ARGC : %d)!", plugin, argc)
		log_error(AMX_ERR_NATIVE, sItem);
		return -1;
	}
	
	ArrayPushString(g_days_itemname, sItem)
	ArrayPushCell(g_days_itemaccess, iAccess)
	ArrayPushCell(g_days_itemlength, fLength)
	ArrayPushCell(g_days_dayendtype, Day_EndType:get_param(4))
	
	g_days_items++;
	return g_days_items-1;
}

// native jb_block_user_weapons(const id, bool:block, bitsum_wpns(allowed/disallowed))
public _block_user_weapons(plugin, argc)
{
	new id = get_param(1);
	
	if(!(1 <= id <= g_iMaxplayers))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid user-id #%d", id)
		return;
	}
	
	new bitsum_wpns = get_param(3)
	
	if(get_param(2))
	{
		if(!bitsum_wpns)
		{
			for(new i = CSW_P228; i <= CSW_P90; i++)
			{
				set_flag(g_user_wpns_blocked[id],i)
			}
		}
		else
		{
			g_user_wpns_blocked[id] |= bitsum_wpns
		}
	}
	else
	{
		if(!bitsum_wpns)
		{
			g_user_wpns_blocked[id] = 0
		}
		else
		{
			g_user_wpns_blocked[id] &= ~bitsum_wpns;
		}
	}
}

// native jb_is_user_weapons_blocked(const id, bitsum_wpns)
public _is_user_weapons_blocked(plugin, argc)
{
	new id = get_param(1)
	
	if(!(0 < id <= g_iMaxplayers))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invalid user-id #%d", id)
		return -1;
	}
	
	new wpns_not_blocked = ~g_user_wpns_blocked[id];
	new bitsum_wpns = get_param(2)
	
	if(!bitsum_wpns)
	{
		return wpns_not_blocked;
	}
	
	return ((g_user_wpns_blocked[id] & bitsum_wpns) == bitsum_wpns) ? 0:wpns_not_blocked;
}

// native jb_cells(bool:open)
public _cells(plugin, argc)
{
	return jb_cells(bool:get_param(1));
}

jb_cells(bool:bOpen=true)
{
	switch( bOpen )
	{
		case true: logevent_message("The cells are opened!")
		default: logevent_message("The cells are closed!")
	}
	
	new iEnt = g_cells_button;
	if(iEnt >= 0)
	{
		if(bOpen)
		{
			ExecuteHamB(Ham_Use, iEnt, 0, 0, 2, 1.0);
		}
		else
		{
			new xValue[64];
			pev(iEnt, pev_target, xValue, charsmax(xValue));
			iEnt = -1;
			while( (iEnt = find_ent_by_tname(iEnt, xValue)) > 0 )
			{
				ExecuteHamB(Ham_CS_Restart, iEnt);
			}
		}
		
		return g_cells_button;
	}
	
	while( (iEnt = engfunc(EngFunc_FindEntityByString, iEnt, "classname", "func_door")) > 0)
	{
		if(bOpen)
		{
			ExecuteHamB(Ham_Use, iEnt, 0, 0, 2, 1.0)
		}
		else
		{
			ExecuteHamB(Ham_CS_Restart, iEnt)
		}
	}
	
	return -1;
}

stock get_itemid_inarray_bystring(const info[], Array:array_name, bool:Equali=true)
{
	new itemname[64], i
	
	for(i = 0; i < ArraySize(array_name); i++)
	{
		ArrayGetString(array_name, i, itemname, charsmax(itemname))
		
		if(Equali ? equali(itemname, info):containi(itemname, info))
		{
			return i;
		}
	}
	return -1;
}

// native register_jailbreak_class(const name[], const playermodel[], const priweapons[], const secweapons[], const flag=0, const team, const vknife[], const pknife[], const knifesounds[])
public _create_class(pluginid, argc)
{
	if(argc != 9)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments: %d are less than the requested value!", pluginid, argc) 
		return -1;
	}
	
	new xArray[CLASSES_DATA], szFlags[32];
	get_string(1, xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]))
	get_string(2, xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]))
	get_string(3, xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]))
	get_string(4, xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]))
	get_flags(get_param(5), szFlags, charsmax(szFlags));
	copy(xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]), SZTEAMS[clamp(get_param(6), TEAM_ANY, TEAM_SPECTATOR)])
	get_string(7, xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]))
	get_string(8, xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]))
	get_string(9, xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]))
	
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_MODEL], xArray[CLASS_MODEL], charsmax(xArray[CLASS_MODEL]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_PRIMARY_WEAPON], xArray[CLASS_PRIMWEAPONS], charsmax(xArray[CLASS_PRIMWEAPONS]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_SECONDARY_WEAPON], xArray[CLASS_SECWEAPONS], charsmax(xArray[CLASS_SECWEAPONS]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_V_KNIFE], xArray[CLASS_V_KNIFE_MDL], charsmax(xArray[CLASS_V_KNIFE_MDL]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_P_KNIFE], xArray[CLASS_P_KNIFE_MDL], charsmax(xArray[CLASS_P_KNIFE_MDL]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_KNIFE_SOUNDS], xArray[CLASS_KNIFE_SOUNDS], charsmax(xArray[CLASS_KNIFE_SOUNDS]))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_FLAGS], szFlags, charsmax(szFlags))
	get_file_keyvalue(jb_classes_ini_file, xArray[CLASS_NAME], szClasses_keys[KEY_CLASS_TEAM], xArray[CLASS_TEAM], charsmax(xArray[CLASS_TEAM]))
	xArray[CLASS_FLAGS] = str_to_num(szFlags);
	
	ArrayPushArray(g_classes_array, xArray);
	
	g_iClasses ++;
	return g_iClasses-1;
}

public _get_user_classid(plugin, argc)
{
	new id = get_param(1);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	return g_iClass[id][fm_get_user_team(id)];
}

public _set_user_classid(plugin, argc)
{
	new classid = get_param(2), id = get_param(1);
	
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	if(!(0 <= (classid = get_param(2)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	if(!jb_is_user_class_valid(id,classid))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id for player team (#%d)", id);
		return 0;
	}
	
	g_iClass[id][fm_get_user_team(id)] = classid;
	return 1;
}

public _get_classname(plugin, argc)
{
	if(argc != 3)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments(%d/3) doesn't match!", plugin, argc) 
		return -1;
	}
	
	new classid;
	if(!(0 <= (classid = get_param(1)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	set_string(2, xArray[CLASS_NAME], get_param(3));
	return 1;
}

public _set_class_newname(plugin, argc)
{
	new classid;
	if(!(0 <= (classid = get_param(1)) < g_iClasses))
	{
		log_error(AMX_ERR_NATIVE, "Error: Invaild class id!");
		return 0;
	}
	
	new new_name[32];
	get_string(2, new_name, charsmax(new_name));
	
	new xArray[CLASSES_DATA];
	ArrayGetArray(g_classes_array, classid, xArray);
	copy(xArray[CLASS_NAME], charsmax(xArray[CLASS_NAME]), new_name)
	ArraySetArray(g_classes_array, classid, xArray)
	return 1;
}

public _set_user_class_model(plugin, argc)
{
	new id = get_param(1);
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	jb_set_user_class_model(id);
	return 1;
}

jb_set_user_class_model(index)
{
	new iTeam, classid = g_iClass[index][(iTeam = fm_get_user_team(index))]
	
	if(jb_is_user_class_valid(index, classid) > 0)
	{	
		new xArray[CLASSES_DATA], sCurrentmodel[32];
		ArrayGetArray(g_classes_array, classid, xArray)
		cs_get_user_model(index, sCurrentmodel, charsmax(sCurrentmodel))
		
		if(!equal(sCurrentmodel, xArray[CLASS_MODEL]) )
		{
			if(!equali(xArray[CLASS_MODEL], "NONE"))
			{
				cs_set_player_model(index, xArray[CLASS_MODEL]);
				return;
			}
			
			switch( iTeam )
			{
				case TEAM_GUARDS: cs_set_player_model(index, gclasses_defmodels[random(sizeof gclasses_defmodels)]);
				case TEAM_PRISONERS: cs_set_player_model(index, pclasses_defmodels[random(sizeof pclasses_defmodels)]);
			}
		}
	}
}

public _is_user_class_valid(plugin, argc)
{
	new id = get_param(1);
	if(!is_user_connected(id))
	{
		log_error(AMX_ERR_NATIVE, "Error: user with this id (#%d) is not connected!", id);
		return 0;
	}
	
	
	return jb_is_user_class_valid(id, get_param(2));
}

jb_is_user_class_valid(id, classid)
{
	if( (0 <= classid < g_iClasses))
	{
		new xArray[CLASSES_DATA], iTeam = fm_get_user_team(id);
		ArrayGetArray(g_classes_array, classid, xArray)
		if(equali(SZTEAMS[TEAM_ANY], xArray[CLASS_TEAM], strlen(SZTEAMS[TEAM_ANY]))) return 1;
		return equali(SZTEAMS[iTeam], xArray[CLASS_TEAM], strlen(SZTEAMS[iTeam])) ? 1:0;
	}
	
	return -1;
}

// native jb_ini_get_keyvalue(const category[], const key[], value[], len)
public jb_get_keyvalue(plugin, cid)
{
	if(cid != 4) return 0;
	
	new cata[48], szKey[48], szValue[140], iLen;
	get_string(1, cata, charsmax(cata));
	get_string(2, szKey, charsmax(szKey));
	get_string(3, szValue, (iLen = get_param(4)));
	get_file_keyvalue(jailbreak_ini_file, cata, szKey, szValue, iLen)
	
	set_string(3, szValue, iLen)
	return 1;
}

// native jb_logmessage(const message[])
public _logmessage(plugin, cid)
{
	if(cid != 1)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments: %d/1 doesn't equal the requested quantity!", plugin, cid) 
		return -1;
	}
	
	static szLogMessage[192];
	get_string(1, szLogMessage, charsmax(szLogMessage))
	logevent_message(szLogMessage);
	return 1;
}

// native register_jailbreak_logmessages(const func[], const logmessage[]);
public register_logmessages(plugin, cid)
{
	if(cid != 2)
	{
		log_error(AMX_ERR_PARAMS, "Plugin-id: #%d | Arguments: %d/2 doesn't equal the requested quantity!", plugin, cid) 
		return -1;
	}
	
	new szString[32], xArray[LOGS_MESSAGES_DATA];
	xArray[LOGMESSAGE_FUNC_PLUGIN_ID] = plugin;
	get_string(1, szString, charsmax(szString))
	xArray[LOGMESSAGE_FUNC_ID] = get_func_id(szString, plugin);
	get_string(2, xArray[LOGMESSAGE_MESSAGE], charsmax(xArray[LOGMESSAGE_MESSAGE]))
	
	ArrayPushArray(g_array_logmessages, xArray)
	
	if(!g_logmessages_hooks)
	{
		register_message(SVC_PRINT, "fw_logmessages");
	}
	
	g_logmessages_hooks ++;
	return g_logmessages_hooks-1;
}

public fw_logmessages(msgid, dest, id)
{
	if(dest != MSG_ALL)
	{
		return;
	}
	
	static szLogMessage[196], szMod[32];
	get_msg_arg_string(1, szLogMessage, charsmax(szLogMessage))
	argbreak(szLogMessage, szMod, charsmax(szMod), szLogMessage, charsmax(szLogMessage))
	
	if(!equal(szMod, "JAILBREAK")) return;
	
	static xArray[LOGS_MESSAGES_DATA], i;
	
	for(i = 0; i < g_logmessages_hooks; i++)
	{
		ArrayGetArray(g_array_logmessages, i, xArray)
		
		if(containi(szLogMessage, xArray[LOGMESSAGE_MESSAGE]) > -1)
		{
			callfunc_begin_i(xArray[LOGMESSAGE_FUNC_ID], xArray[LOGMESSAGE_FUNC_PLUGIN_ID])
			{
				callfunc_push_str(szLogMessage, false);
			}
			callfunc_end();
		}
	}
}

stock get_file_keyvalue(const file[], const cata[], const key[], value[], len)
{
	static sFile[128], fp;
	formatex(sFile, charsmax(sFile), "%s/%s", CONFIGS_DIR, file);
	
	fp = fopen(sFile, "a+");
	
	if(!fp)
	{
		set_fail_state("Error opening the file!")
		return 0;
	}
	
	static sBuffer[256], szCata[64], szKey[64], key_found, cata_found, line, bool:key_update;
	key_found = -1;
	cata_found = -1;
	line = -1;
	key_update = false;
	
	while(!feof(fp))
	{
		line ++;
		
		fgets(fp, sBuffer, charsmax(sBuffer));
		trim(sBuffer);
		
		if(!sBuffer[0] || strlen(sBuffer) <= 3 || sBuffer[0] == ';' || (sBuffer[0] == '/' && sBuffer[1] == '/'))
			continue;
		
		if(sBuffer[0] == '[' && cata_found == -1 && contain(sBuffer[1], "]") > -1)
		{
			copyc(szCata, charsmax(szCata), sBuffer[1], ']');
			
			if(equali(szCata, cata))
			{
				cata_found = line;
			}
			
			continue;
		}
		
		if(cata_found > -1 && key_found == -1)
		{
			strtok(sBuffer, szKey, charsmax(szKey), sBuffer, charsmax(sBuffer), '=')
			trim(szKey);
			trim(sBuffer);
			remove_quotes(szKey);
			remove_quotes(sBuffer);
			
			if(equali(szKey, key))
			{
				key_found = line;
				
				if(!sBuffer[0])
				{
					key_update = true;
					break;
				}
				
				copy(value, len, sBuffer)
				break;
			}
		}
	}
	
	if(cata_found == -1)
	{
		formatex(szCata, charsmax(szCata), "[%s]", cata)
		fputc(fp, '^n');
		fputs(fp, szCata);
		fputc(fp, '^n');
		
		formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^"", key, value)
		fputs(fp, sBuffer);
		fputc(fp, '^n');
	}
	
	if((key_found == -1 && cata_found > -1) || key_update == true) 
	{
		static sFile2[128], fp2;
		formatex(sFile2, charsmax(sFile2), "%s/2_%s", CONFIGS_DIR, file);
		
		fp2 = fopen(sFile2, "wt");
		
		if(!fp2)
		{
			set_fail_state("Error opening the file!")
			return 0;
		}
		
		line = -1;
		fseek(fp, 0, SEEK_SET);
		while((fgets(fp, sBuffer, charsmax(sBuffer)) > 0))
		{
			line ++;
			trim(sBuffer);
			
			if(key_update == true)
			{
				if(key_found == line)
				{
					formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^"", key, value)
				}
			}
			else if(cata_found == line)
			{
				formatex(szCata, charsmax(szCata), "[%s]", cata)
				fputs(fp2, szCata);
				fputc(fp2, '^n');
				formatex(sBuffer, charsmax(sBuffer), "%s = ^"%s^"", key, value)
			}
			
			fputs(fp2, sBuffer);
			fputc(fp2, '^n');
		}
		fclose(fp);
		fclose(fp2);
		
		delete_file(sFile);
		if(!rename_file(sFile2, sFile,1)) delete_file(sFile2);
		
		return 1;
	}
	
	fclose(fp);
	return 1;
}

logevent_message(const message[], any:...)
{
	new szBuffer[192];
	vformat(szBuffer, charsmax(szBuffer), message, 2);
	format(szBuffer, charsmax(szBuffer), "JAILBREAK %s", szBuffer);
	
	log_message(szBuffer);
	
	emessage_begin(MSG_ALL, SVC_PRINT)
	ewrite_string(szBuffer)
	emessage_end()
}

/* print colorful chat :) */
stock cprint_chat(id, team='n', const message[], any:...)
{
	new sBuffer[192];
	vformat(sBuffer, charsmax(sBuffer), message, 4)
	format(sBuffer, charsmax(sBuffer), "%s %s", TAG, sBuffer)
	
	replace_all(sBuffer, charsmax(sBuffer), "!g", "^4")
	replace_all(sBuffer, charsmax(sBuffer), "!y", "^1")
	replace_all(sBuffer, charsmax(sBuffer), "!t", "^3")
	
	if(!id) // when id is 0 or negative the team parameter has - effect.
	{
		new players[32], num, i;
		
		switch( team ) 
		{
			case 'c': get_players(players, num, "che", "CT")
			case 't': get_players(players, num, "che", "TERRORIST")
			default: get_players(players, num, "ch")
		}
		
		while( i < num )
		{
			id = players[i];
			
			message_begin(MSG_ONE, g_msgSayText, _, id)
			write_byte(id)
			write_string(sBuffer)
			message_end()
			
			i++
		}
	}
	else
	{
		if(is_user_connected(id)) // to a specified player...
		{
			message_begin(MSG_ONE, g_msgSayText, _, id)
			write_byte(id)
			write_string(sBuffer)
			message_end()
		}
	}
}

stock argbreak(const text[], left[], leftlen, right[], rightlen)
{
	new pos = argparse(text, 0, left, leftlen);

	if (pos == -1)
	{
		return -1;
	}

	new textlen = strlen(text);

	while (pos < textlen && isspace(text[pos]))
	{
		pos++;
	}

	copy(right, rightlen, text[pos]);

	return pos;
}
